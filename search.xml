<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>个人阅读/学习列表，持续更新...</title>
      <link href="/2019/09/28/joke-read-study-list/"/>
      <url>/2019/09/28/joke-read-study-list/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要说明"><a href="#摘要说明" class="headerlink" title="摘要说明"></a>摘要说明</h3><ul><li>本文罗列了个人正在或已经完成的阅读/学习资料、书籍等</li><li>本文持续更新，不断优化，践行终身学习</li></ul><a id="more"></a><h3 id="思维与认知"><a href="#思维与认知" class="headerlink" title="思维与认知"></a>思维与认知</h3><h4 id="李笑来-《把时间当做朋友》"><a href="#李笑来-《把时间当做朋友》" class="headerlink" title="李笑来-《把时间当做朋友》"></a>李笑来-《把时间当做朋友》</h4><ul><li>资源：作者github有公开电子版-<a href="https://github.com/xiaolai/time-as-a-friend" target="_blank" rel="noopener">点击查看</a></li><li>个人简评：<ul><li>本书虽然有那么一些说教，但整体上比一般成功学鸡汤更有营养一点，帮我们认清并破除人性的一系列弱点，更具实操性，只要肯实践，一般都会有些收获</li><li>我们常常随波逐流、缺少深入思考、缺乏主见，还是很有必要读一读此书的，可以帮助我们打开心智、培养独立思考的能力，如果已经参透人生道理的人可以忽略</li><li>书中把心理学的心智(Mind)、元认知(Metacognition)等概念结合实践做了细致讲解，更通俗易懂，可以当作启蒙读物，如果想进一步研究的可以阅读相关心理学书籍</li></ul></li><li>关键概念：<ul><li>自我管理：时间不可管理，应用把时间当作朋友，在正确的时间和地点、用正确的方法做正确的事，把注意力放在重要事情上，不断积累，不断成长</li><li>元认知：玩过C++的可以对比下“模板元编程”，应用到个人思维上就是要时刻反思、矫正、优化自己的思维方式，不断升级自己的思维，类似人工智能领域的强化学习，而这个概念古人早有说明“吾日三省吾身”</li></ul></li><li>扩展思考：<ul><li>知识多元化：现代社会愈加复杂，信息大爆炸，对人们更加要求有多元化技能、融会贯通的思考能力，我们应该避免“选择性输入”知识，导致大脑“营养不良”，而我们在打造一专多能的时候，还是要珍惜注意力，学会做好决策和筛选，抓住相对重要的事情</li><li>关于思考：80%的人不愿思考（“大多数人宁愿早死也不愿思考-事实上他们也的确是死得早”-大哲学家罗素），剩下的20%里面又有80%常常陷入思维陷阱、错误地思考着，破除思维误区可以阅读比尔盖茨推荐的汉斯罗斯林(Hans Rosling)著的《事实(Factfulness)》一书</li></ul></li></ul><h3 id="原则与方法"><a href="#原则与方法" class="headerlink" title="原则与方法"></a>原则与方法</h3><h4 id="史蒂芬柯维-Stephen-Covey-《要事第一-First-Thing-First-1994-》"><a href="#史蒂芬柯维-Stephen-Covey-《要事第一-First-Thing-First-1994-》" class="headerlink" title="史蒂芬柯维(Stephen Covey)-《要事第一(First Thing First, 1994)》"></a>史蒂芬柯维(Stephen Covey)-《要事第一(First Thing First, 1994)》</h4><ul><li>关键概念：<ul><li>事情划分轻重缓急，抓住重点，珍惜注意力，优先做重要、紧急的事情<h4 id="史蒂芬柯维-Stephen-Covey-《高效能人士的七个习惯-Seven-Habits-of-Highly-Effective-People-1989-》"><a href="#史蒂芬柯维-Stephen-Covey-《高效能人士的七个习惯-Seven-Habits-of-Highly-Effective-People-1989-》" class="headerlink" title="史蒂芬柯维(Stephen Covey)-《高效能人士的七个习惯(Seven Habits of Highly Effective People, 1989)》"></a>史蒂芬柯维(Stephen Covey)-《高效能人士的七个习惯(Seven Habits of Highly Effective People, 1989)》</h4></li></ul></li></ul><h3 id="战略与战术"><a href="#战略与战术" class="headerlink" title="战略与战术"></a>战略与战术</h3><h3 id="生活与职业"><a href="#生活与职业" class="headerlink" title="生活与职业"></a>生活与职业</h3><h3 id="设计与架构"><a href="#设计与架构" class="headerlink" title="设计与架构"></a>设计与架构</h3><h3 id="技术与框架"><a href="#技术与框架" class="headerlink" title="技术与框架"></a>技术与框架</h3>]]></content>
      
      
      <categories>
          
          <category> 终身学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 书籍 </tag>
            
            <tag> 资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>study-movie-resolution</title>
      <link href="/2019/09/08/study-video-resolution/"/>
      <url>/2019/09/08/study-video-resolution/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul><li>今天在爱奇艺看纪录片，发现还有 1080p50 分辨率的，比较好奇，于是进一步了解了下视频分辨率</li><li>高清的之前一直有了解有，720p、1080p，现在冒出的720p50、1080p50又是个啥？</li></ul><h3 id="720p50、1080p50"><a href="#720p50、1080p50" class="headerlink" title="720p50、1080p50"></a>720p50、1080p50</h3><h3 id="提供p50视频的网站"><a href="#提供p50视频的网站" class="headerlink" title="提供p50视频的网站"></a>提供p50视频的网站</h3><h4 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h4><p><a href="https://www.iqiyi.com/v_19rrm476o8.html" target="_blank" rel="noopener">https://www.iqiyi.com/v_19rrm476o8.html</a></p><h4 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h4><p><a href="https://www.youtube.com/watch?v=2MCf-2WTgjk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2MCf-2WTgjk</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>杀毒软件选择</title>
      <link href="/2019/09/08/choose-antivirus-software/"/>
      <url>/2019/09/08/choose-antivirus-software/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要说明"><a href="#摘要说明" class="headerlink" title="摘要说明"></a>摘要说明</h3><ul><li>Windows 10 自带的 Windows Defender 也具有基本的杀毒能力</li><li>国内杀毒软件可能有广告、行为可能不检点，杀毒能力也欠缺一点</li><li>可以参考有标准、有测评、有数据的对比文章，再进行决策</li><li>国外杀毒软件可能有点水土不服，可能会有个别误报</li><li>本文虽然是给 Windows 10 系统物色软件，这些软件基本都是跨平台适用的</li><li>本文是个人在当前所掌握的信息下做出的个人判断，可能有误，欢迎指正</li></ul><a id="more"></a><h3 id="Windows-Defender"><a href="#Windows-Defender" class="headerlink" title="Windows Defender"></a>Windows Defender</h3><p><a href="https://www.microsoft.com/zh-cn/windows/comprehensive-security" target="_blank" rel="noopener">https://www.microsoft.com/zh-cn/windows/comprehensive-security</a><br><img src="WindowsDefender设置.png" alt="WindowsDefender设置.png"></p><h3 id="杀毒软件排行榜-2018"><a href="#杀毒软件排行榜-2018" class="headerlink" title="杀毒软件排行榜-2018"></a>杀毒软件排行榜-2018</h3><p><a href="https://reviewedbypro.com/free-antivirus-2018-bitdefender-antivirus-free-edition-vs-avast-free-antivirus/" target="_blank" rel="noopener">https://reviewedbypro.com/free-antivirus-2018-bitdefender-antivirus-free-edition-vs-avast-free-antivirus/</a><br><img src="杀毒软件排行榜-2018.png" alt="杀毒软件排行榜-2018.png"></p><h3 id="杀毒软件对比-2019"><a href="#杀毒软件对比-2019" class="headerlink" title="杀毒软件对比-2019"></a>杀毒软件对比-2019</h3><p>Windows Defender vs Avast：<a href="https://showbox.fun/windows-defender-vs-avast/" target="_blank" rel="noopener">https://showbox.fun/windows-defender-vs-avast/</a><br>–结论：Avast在功能、系统资源占用等多方面胜出<br>Avast vs Bitdefender：<a href="https://www.proficientblogging.com/bitdefender-vs-avast/" target="_blank" rel="noopener">https://www.proficientblogging.com/bitdefender-vs-avast/</a><br>–结论：不分伯仲，Bitdefender在功能和对系统影响上略胜一筹，Avast更流行</p><h3 id="最终选择"><a href="#最终选择" class="headerlink" title="最终选择"></a>最终选择</h3><p>个人考虑对系统性能的影响，本来选择了 Bitdefender，但是安装包下载不了，<br>最终选择了 Avast，且Avast有中文版<br><img src="Avast杀毒软件功能选项.png" alt="Avast杀毒软件功能选项.png"></p><h3 id="官方下载"><a href="#官方下载" class="headerlink" title="官方下载"></a>官方下载</h3><p>Bitdefender免费版：<a href="https://www.bitdefender.com/solutions/free.html" target="_blank" rel="noopener">https://www.bitdefender.com/solutions/free.html</a><br>Avast免费版：<a href="https://www.avast.com/zh-cn/download-thank-you.php?product=FAV-ONLINE&amp;locale=zh-cn" target="_blank" rel="noopener">h</a><a href="https://www.avast.com/zh-cn/free-antivirus-download" target="_blank" rel="noopener">https://www.avast.com/zh-cn/free-antivirus-download</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杀毒软件 </tag>
            
            <tag> Windows10 </tag>
            
            <tag> WindowsDefender </tag>
            
            <tag> Avast </tag>
            
            <tag> Bitdefender </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎学习</title>
      <link href="/2019/09/06/study-search-engine/"/>
      <url>/2019/09/06/study-search-engine/</url>
      
        <content type="html"><![CDATA[<p> 搜索引擎学习笔记</p><a id="more"></a><p><a name="qe0gG"></a></p><h3 id="2019搜索引擎对比"><a href="#2019搜索引擎对比" class="headerlink" title="2019搜索引擎对比"></a>2019搜索引擎对比</h3><p><a name="fvias"></a></p><h3 id="Top搜索引擎使用"><a href="#Top搜索引擎使用" class="headerlink" title="Top搜索引擎使用"></a>Top搜索引擎使用</h3><p><a name="BbjEK"></a></p><h3 id="搜索引擎源码学习"><a href="#搜索引擎源码学习" class="headerlink" title="搜索引擎源码学习"></a>搜索引擎源码学习</h3><p><a name="QvLnG"></a></p><h3 id="搜索引擎理论学习"><a href="#搜索引擎理论学习" class="headerlink" title="搜索引擎理论学习"></a>搜索引擎理论学习</h3>]]></content>
      
      
      <categories>
          
          <category> 搜索引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
            <tag> Elastic Search </tag>
            
            <tag> Solr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use-django</title>
      <link href="/2014/12/03/use-django/"/>
      <url>/2014/12/03/use-django/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安装配置Ubuntu_14.04_amd64</title>
      <link href="/2014/12/02/install-configure-ubuntu/"/>
      <url>/2014/12/02/install-configure-ubuntu/</url>
      
        <content type="html"><![CDATA[<p>本文的一些设置仅适用于13.04及以后的Ubuntu版本。</p><h3 id="Ubuntu镜像下载"><a href="#Ubuntu镜像下载" class="headerlink" title="Ubuntu镜像下载"></a>Ubuntu镜像下载</h3><p>中科大的源在全国都比较快速和稳定：<br>西电的同学可以在本校或兄弟学校成电的镜像网站下载，都比比中科大更快，但是西电的源没有成电的稳定：<br><a href="http://ubuntu.uestc.edu.cn/ubuntu-release/" target="_blank" rel="noopener">http://ubuntu.uestc.edu.cn/ubuntu-release/</a><br><a href="http://ftp.xdlinux.info/iso/ubuntu/" target="_blank" rel="noopener">http://ftp.xdlinux.info/iso/ubuntu/</a></p><a id="more"></a><p>###<br>参考：<a href="http://blog.chinaunix.net/uid-20940095-id-4216696.html" target="_blank" rel="noopener">硬盘安装ubuntu 14.04 LTS</a>、<a href="http://blog.chinaunix.net/uid-21222282-id-1829061.html" target="_blank" rel="noopener">GRUB启动命令详解</a></p><h3 id="更改启动菜单等待时间"><a href="#更改启动菜单等待时间" class="headerlink" title="更改启动菜单等待时间"></a>更改启动菜单等待时间</h3><ul><li><p>安装vim - vi improved</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim</span><br></pre></td></tr></table></figure></li><li><p>修改默认grub配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure></li></ul><p>修改其中的<code>GRUP_TIMEOUT=10</code>，我一般改为‘3’，然后更新grub：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-grub</span><br></pre></td></tr></table></figure></p><p><code>/boot/grub/grub.cfg</code>中的系统选择菜单倒计时会更新，以后每次更新内核，都会自动读取默认的grub设置。</p><h3 id="64位Ubuntu14-04安装32位iNode客户端"><a href="#64位Ubuntu14-04安装32位iNode客户端" class="headerlink" title="64位Ubuntu14.04安装32位iNode客户端"></a>64位Ubuntu14.04安装32位iNode客户端</h3><h4 id="首先安装32位库ia32-libs"><a href="#首先安装32位库ia32-libs" class="headerlink" title="首先安装32位库ia32-libs"></a>首先安装32位库<code>ia32-libs</code></h4><p>新版Ubuntu不再使用这个库了，故首先需要添加旧版系统的软件源，然后安装<code>ia32-libs</code>，之后再删除旧版系统的源。<br>创建<code>install-ia32-libs.sh</code>文件，填入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/apt/sources.list.d</span><br><span class="line">echo &quot;deb http://ubuntu.uestc.edu.cn/ubuntu/ precise main restricted universe multiverse&quot; &gt;ia32-libs-raring.list</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install ia32-libs</span><br><span class="line">rm ia32-libs-raring.list</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure></p><p>在终端里输入<code>sudo install-ia32-libs.sh</code>执行脚本。<br>参考：<a href="http://andycoder.me/fix-32bug-under-ubuntu1404/" target="_blank" rel="noopener">如何在ubuntu14.04(64位)编译运行32位程序</a>、<a href="http://zodiacg.net/2011/07/howto_install_32bit_app_in_64bit_ubuntu/" target="_blank" rel="noopener">如何在64位Ubuntu下安装32位应用程序</a></p><h4 id="安装iNode客户端"><a href="#安装iNode客户端" class="headerlink" title="安装iNode客户端"></a>安装iNode客户端</h4><p>将iNodeClient_Linux.tar.gz放到主文件夹里，然后安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar -zxvf ~/iNodeClient_Linux.tar.gz -C /opt</span><br><span class="line">$ <span class="built_in">cd</span> /opt/iNodeClient</span><br><span class="line">$ sudo ./install.sh</span><br></pre></td></tr></table></figure></p><p>装完后，双击<code>/opt/iNodeClient/iNodeClient</code>即可运行。<br>说明：第三方软件一般安装到<code>/opt</code>(optional)目录，以前通常安装到<code>/usr/local/</code>(unix software repository, local代表本地，区别于用apt-get从网络源中安装的软件)中。<br>注意：必须进入iNode目录执行<code>./install.sh</code>安装，该脚本应该使用了当前工作目录(pwd)。<br>如果提示缺少库，请参考：<a href="http://blog.chinaunix.net/uid-26919525-id-3192877.html" target="_blank" rel="noopener">Ubutu 12.04 LTS 安装iNode 后缺少libjpeg.so.62与libtiff.so.3解决方法</a></p><h3 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h3><p>点击右上角开关机图标，进入“系统设置-&gt;软件和更新-&gt;Ubuntu软件-&gt;下载自”，在下拉列表中选择“其他站点…”，然后就近选择一个中国地区的源。可以通过ping比较一下延时，网易云（mirrors.163.com）和阿里云（mirrors.aliyun.com）在全国都有较好的速度；教育网用户首选本校或附近的源，如果没有，可以选择中科大的源（mirrors.ustc.edu.cn），在所有高校都有较快的访问速度；西电同学首选成电的（ubuntu.uestc.edu.cn）或本校的源（需要自己添加，<strong>不太稳定，有些软件包无法下载</strong>）。</p><h3 id="西电源设置："><a href="#西电源设置：" class="headerlink" title="西电源设置："></a>西电源设置：</h3><p>备份软件源：<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code>，然后<br>编辑 /etc/apt/sources.list (<code>sudo gedit /etc/apt/sources.list</code>)替换为或者加入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://ftp.xdlinux.info/ubuntu/ trusty main multiverse restricted universe</span><br><span class="line">deb http://ftp.xdlinux.info/ubuntu/ trusty-backports main multiverse restricted universe</span><br><span class="line">deb http://ftp.xdlinux.info/ubuntu/ trusty-proposed main multiverse restricted universe</span><br><span class="line">deb http://ftp.xdlinux.info/ubuntu/ trusty-security main multiverse restricted universe</span><br><span class="line">deb http://ftp.xdlinux.info/ubuntu/ trusty-updates main multiverse restricted universe</span><br><span class="line">deb-src http://ftp.xdlinux.info/ubuntu/ trusty main multiverse restricted universe</span><br><span class="line">deb-src http://ftp.xdlinux.info/ubuntu/ trusty-backports main multiverse restricted universe</span><br><span class="line">deb-src http://ftp.xdlinux.info/ubuntu/ trusty-proposed main multiverse restricted universe</span><br><span class="line">deb-src http://ftp.xdlinux.info/ubuntu/ trusty-security main multiverse restricted universe</span><br><span class="line">deb-src http://ftp.xdlinux.info/ubuntu/ trusty-updates main multiverse restricted universe</span><br></pre></td></tr></table></figure></p><p>使用 sudo apt-get update 同步本地包数据库。<br>使用 sudo apt-get upgrade 升级所有已安装的软件包。<br>参考：<a href="http://xdlinux.info/wiki/index.php?title=Mirror/ubuntu" target="_blank" rel="noopener">Mirror/ubuntu</a><br>其他软件源：<a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">Ubuntu源列表</a></p><h3 id="安装新立德包管理器"><a href="#安装新立德包管理器" class="headerlink" title="安装新立德包管理器"></a>安装新立德包管理器</h3><p>Ubuntu软件中心运行速度很慢，追求性能的用户可以用以前的新立德代替。<br><code>sudo apt-get install synaptic</code></p><h3 id="在启动栏（Launcher）上添加“显示桌面”图标"><a href="#在启动栏（Launcher）上添加“显示桌面”图标" class="headerlink" title="在启动栏（Launcher）上添加“显示桌面”图标"></a>在启动栏（Launcher）上添加“显示桌面”图标</h3><p>右击“更改桌面背景”，在“外观-&gt;行为”中勾选“添加‘显示桌面’图标到启动器”，此外也可以用快捷键“Ctrl+Win+D”，<strong>Unity桌面系统中长按Win键（Super键）会显示所有键盘快捷键</strong>。<br>参考：<a href="http://askubuntu.com/questions/126540/how-to-add-a-show-desktop-icon-to-the-launcher" target="_blank" rel="noopener">How to add a “Show desktop” icon to the launcher?</a></p><h3 id="双击sh脚本弹出提示框"><a href="#双击sh脚本弹出提示框" class="headerlink" title="双击sh脚本弹出提示框"></a>双击sh脚本弹出提示框</h3><blockquote><p>自从13.04以后，双击sh脚本文件就已经默认是geidt打开了，要想运行，从“nautilus（文件）–&gt;编辑–&gt;首选项–&gt;行为–&gt;可执行文本文件”组中选择“每次都询问”。<br>记得在脚本文件右键“属性”，在“权限-&gt;执行”中勾选“允许作为程序执行文件”。<br>参考：<a href="http://www.cnblogs.com/Findxiaoxun/p/3558994.html" target="_blank" rel="noopener">ubuntu sh脚本双击运行</a></p></blockquote><h3 id="安装桌面"><a href="#安装桌面" class="headerlink" title="安装桌面"></a>安装桌面</h3><p><a href="http://www.linuxmint.com/download.php" target="_blank" rel="noopener">Download Linux Mint 17.1 Rebecca</a><br><a href="http://cinnamon.linuxmint.com/" target="_blank" rel="noopener">http://cinnamon.linuxmint.com/</a><br><a href="http://wiki.mate-desktop.org/download" target="_blank" rel="noopener">http://wiki.mate-desktop.org/download</a></p><h3 id="安装浏览器"><a href="#安装浏览器" class="headerlink" title="安装浏览器"></a>安装浏览器</h3><h4 id="遨游：http-www-maxthon-cn"><a href="#遨游：http-www-maxthon-cn" class="headerlink" title="遨游：http://www.maxthon.cn/"></a>遨游：<a href="http://www.maxthon.cn/" target="_blank" rel="noopener">http://www.maxthon.cn/</a></h4><p>32位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># wget http://dl.maxthon.cn/linux/deb/packages/i386/maxthon-browser-stable_1.0.5.3_i386.deb</span><br><span class="line"># dpkg -i maxthon-browser-stable_1.0.5.3_i386.deb</span><br></pre></td></tr></table></figure></p><p>64位：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget http://dl.maxthon.cn/linux/deb/packages/amd64/maxthon-browser-stable_1.0.5.3_amd64.deb</span></span><br><span class="line"><span class="comment"># dpkg -i maxthon-browser-stable_1.0.5.3_amd64.deb</span></span><br></pre></td></tr></table></figure></p><h3 id="Ubuntu14-04配置开发环境"><a href="#Ubuntu14-04配置开发环境" class="headerlink" title="Ubuntu14.04配置开发环境"></a>Ubuntu14.04配置开发环境</h3><ul><li>完整设置<br>参考：<a href="https://github.com/iamcoach/linux-setup/blob/master/Ubuntu.md" target="_blank" rel="noopener">Ubuntu 14.04 Setup</a></li></ul><p>###<br>为root用户设置密码：<code>sudo passwd root</code><br>在终端进入root用户：<code>su</code></p><p>###<br><a href="http://packages.ubuntu.com/search?keywords=search" target="_blank" rel="noopener">Ubuntu软件包搜索</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Nginx+uWSGI+Django+MySQL服务器</title>
      <link href="/2014/11/28/Nginx-uWSGI-Django-MySQL/"/>
      <url>/2014/11/28/Nginx-uWSGI-Django-MySQL/</url>
      
        <content type="html"><![CDATA[<p>为了将PHP改为Python，使用了Django搭建LNMP服务器，<br>下面命名默认Ubuntu系统，且用root账户登录，关于如何以管理员身份登录，请参考：<a href="http://www.ubuntukylin.com/ukylin/forum.php?mod=viewthread&amp;tid=8445" target="_blank" rel="noopener">Ubuntu Kylin14.04终于可以使用root登陆了</a>。<br>请注意：在创建mysite工程后，命令运行目录为：/python_workspace/mysite。</p><a id="more"></a><p>## </p><h3 id="安装-python-和-python-dev"><a href="#安装-python-和-python-dev" class="headerlink" title="安装 python 和 python-dev"></a>安装 python 和 python-dev</h3><p>Ubuntu发行版自带python；<br>如果没安装python-dev会遇到”致命错误：Python.h：没有那个文件或目录”错误；<br>为了兼容性，选用Python2.x，<code>python --version</code>查看版本；<br>参考：<a href="http://django-china.cn/topic/101/" target="_blank" rel="noopener">五步教你实现使用Nginx+uWSGI+Django方法部署Django程序(上)</a></p><h3 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># wget https://raw.github.com/pypa/pip/master/contrib/get-pip.py</span><br><span class="line"># python get-pip.py</span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.jsxubar.info/install-pip.html" target="_blank" rel="noopener">pip安装和使用教程</a></p><h3 id="安装并测试uWSGI"><a href="#安装并测试uWSGI" class="headerlink" title="安装并测试uWSGI"></a>安装并测试uWSGI</h3><ul><li><p>利用pip安装uwsgi：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># export LDFLAGS=&quot;-Xlinker --no-as-needed&quot;</span><br><span class="line"># pip install uwsgi</span><br></pre></td></tr></table></figure></li><li><p>测试uwsgi：<br>在你的机器上写一个test.py并填入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def application(env, start_response):</span><br><span class="line">    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;,&apos;text/html&apos;)])</span><br><span class="line">    return &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></li></ul><p>然后执行shell命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --http :8001 --wsgi-file test.py</span><br></pre></td></tr></table></figure></p><p>访问网页：<code>http://127.0.0.1:8001/</code>，看在网页上是否有Hello World。<br>引用：<a href="http://django-china.cn/topic/101/" target="_blank" rel="noopener">五步教你实现使用Nginx+uWSGI+Django方法部署Django程序(上)</a></p><h3 id="安装并配置Django"><a href="#安装并配置Django" class="headerlink" title="安装并配置Django"></a>安装并配置Django</h3><ul><li>安装Django<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pip install Django</span><br></pre></td></tr></table></figure></li></ul><p>参考：<a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">How to get Django</a>、<a href="http://www.ziqiangxuetang.com/django/django-install.html" target="_blank" rel="noopener">Django 环境搭建</a></p><ul><li>创建项目并测试：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -p /python_workspace</span><br><span class="line"># cd /python_workspace</span><br><span class="line"># django-admin.py startproject mysite</span><br><span class="line"># cd mysite</span><br><span class="line"># python manage.py runserver 0.0.0.0:8001</span><br></pre></td></tr></table></figure></li></ul><p>在浏览器里输入<code>localhost:8001</code>或<code>127.0.0.1:8001</code>查看效果。<br>参考：<a href="http://www.jb51.net/article/43404.htm" target="_blank" rel="noopener">使用python搭建Django应用程序步骤及版本冲突问题解决</a>、<a href="http://www.linuxyw.com/353.html" target="_blank" rel="noopener">nginx+uwsgi+django+python环境部署文档</a></p><ul><li>uwsgi调用Django：<br>Django1.4+在创建工程的时候会自动创建wsgi模块，进入工程目录(mysite)，执行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --http :8001 --module mysite.wsgi</span><br></pre></td></tr></table></figure></li></ul><p>在浏览器里输入<code>localhost:8001</code>或<code>127.0.0.1:8001</code>查看是否有Django页面。<br>参考：<a href="https://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html?highlight=django" target="_blank" rel="noopener">Setting up Django and your web server with uWSGI and nginx</a></p><h3 id="安装Nginx并配置："><a href="#安装Nginx并配置：" class="headerlink" title="安装Nginx并配置："></a>安装Nginx并配置：</h3><p>本节主要参考：<a href="https://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html?highlight=django" target="_blank" rel="noopener">Setting up Django and your web server with uWSGI and nginx</a></p><ul><li>安装测试Nginx<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get install nginx</span></span><br><span class="line"><span class="comment"># /etc/init.d/nginx start    # start nginx</span></span><br></pre></td></tr></table></figure></li></ul><p>在浏览器里输入<code>localhost:80</code>或<code>127.0.0.1:80</code>查看是否有Nginx页面。</p><ul><li>Nginx调用（连接）uWSGI<br>将uwsgi_params拷贝到Django工程目录中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cp /etc/nginx/uwsgi_params ./</span><br></pre></td></tr></table></figure></li></ul><p>在工程目录中创建mysite_nginx.conf文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># mysite_nginx.conf</span><br><span class="line">#</span><br><span class="line"># the upstream component nginx needs to connect to</span><br><span class="line">upstream django &#123;</span><br><span class="line">    server unix:///python_workspace/mysite/mysite.sock; # for a file socket</span><br><span class="line">    #server 127.0.0.1:8000; # for a web port socket (we&apos;ll use this first)</span><br><span class="line">&#125;</span><br><span class="line">#</span><br><span class="line"># configuration of the server</span><br><span class="line">server &#123;</span><br><span class="line">    # the port your site will be served on</span><br><span class="line">    listen      8001;</span><br><span class="line">    # the domain name it will serve for</span><br><span class="line">    server_name 127.0.0.1; # 测试用的是回环地址，应该设为公网IP或域名</span><br><span class="line">    charset     utf-8;</span><br><span class="line"></span><br><span class="line">    # max upload size</span><br><span class="line">    client_max_body_size 75M;   # adjust to taste</span><br><span class="line"></span><br><span class="line">    # Django media</span><br><span class="line">    location /media  &#123;</span><br><span class="line">        alias /python_workspace/mysite/media;  # 媒体文件目录</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /static &#123;</span><br><span class="line">        alias /python_workspace/mysite/static; # 静态文件目录</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # Finally, send all non-media requests to the Django server.</span><br><span class="line">    location / &#123;</span><br><span class="line">        uwsgi_pass  django;</span><br><span class="line">        include     /python_workspace/mysite/uwsgi_params; # the uwsgi_params file you installed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Nginx的相应目录中建立软链接，使其能找到该文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ln -s /python_workspace/mysite/mysite_nginx.conf /etc/nginx/sites-enabled/</span><br></pre></td></tr></table></figure></p><p>部署静态文件：在mysite/settings.py最后添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, &quot;static/&quot;)</span><br></pre></td></tr></table></figure></p><p>运行<code>python manage.py collectstatic</code>将默认的静态拷贝到新目录。<br>重启Nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/nginx restart</span><br></pre></td></tr></table></figure></p><p>放置<code>media.png</code>到上面设置的media目录，并在浏览器里访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:8001/media/media.png</span><br></pre></td></tr></table></figure></p><p>创建uWSGI运行脚本<code>mysite_uwsgi.ini</code>并填入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># mysite_uwsgi.ini file</span><br><span class="line">[uwsgi]</span><br><span class="line">#</span><br><span class="line"># Django-related settings</span><br><span class="line"># the base directory (full path)</span><br><span class="line">chdir           = /python_workspace/mysite</span><br><span class="line"># Django&apos;s wsgi file</span><br><span class="line">module          = mysite.wsgi</span><br><span class="line"># the virtualenv (full path)</span><br><span class="line">#home            = /path/to/virtualenv</span><br><span class="line">#</span><br><span class="line"># process-related settings</span><br><span class="line"># master</span><br><span class="line">master          = true</span><br><span class="line"># maximum number of worker processes</span><br><span class="line">processes       = 3 # 开启3个uwsgi工作进程</span><br><span class="line"># the socket (use the full path to be safe</span><br><span class="line">socket          = /python_workspace/mysite/mysite.sock</span><br><span class="line"># ... with appropriate permissions - may be needed</span><br><span class="line">chmod-socket    = 666</span><br><span class="line"># clear environment on exit</span><br><span class="line">vacuum          = true</span><br></pre></td></tr></table></figure></p><p>运行脚本启动uWSGI：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># uwsgi --ini mysite_uwsgi.ini</span><br></pre></td></tr></table></figure></p><p>（前提是Nginx要运行着）在浏览器里访问<code>127.0.0.1:8001</code>，应该可以看到Django页面。</p><h3 id="安装配置MySQL"><a href="#安装配置MySQL" class="headerlink" title="安装配置MySQL"></a>安装配置MySQL</h3><ul><li>安装MySQL<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># apt-get install mysql-server</span><br></pre></td></tr></table></figure></li></ul><p>参考：<a href="http://wiki.ubuntu.org.cn/MySQL%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">MySQL安装指南</a><br>如果打开MySQL出现错误（<strong>仅在出现错误时尝试下面的方法</strong>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR 2002 (HY000): </span><br><span class="line">Can&apos;t connect to local MySQL server through socket </span><br><span class="line">&apos;/var/run/mysqld/mysqld.sock&apos; (2)</span><br></pre></td></tr></table></figure></p><p>需要将MySQL的socket设置为上面的路径（需要修改三处，该方法不一定有效）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit /etc/mysql/my.cn</span><br></pre></td></tr></table></figure></p><p><img src="http://keke-hexo-blog.qiniudn.com/image/Django/MySQL-socket.png" alt><br>参考：<a href="http://stackoverflow.com/questions/11990708/error-cant-connect-to-local-mysql-server-through-socket-var-run-mysqld-mysq" target="_blank" rel="noopener">error: ‘Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2)’</a></p><ul><li>选择MySQL DB API Drivers<a href="https://docs.djangoproject.com/en/1.7/ref/databases/#mysql-notes" target="_blank" rel="noopener">^Mysql-notes</a></li><li>，本文使用MySQLdb，即mysql-python模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># apt-get install python-setuptools</span><br><span class="line"># apt-get install libmysqld-dev</span><br><span class="line"># apt-get install libmysqlclient-dev</span><br><span class="line"># easy_install mysql-python</span><br><span class="line"># apt-get install python-mysqldb</span><br></pre></td></tr></table></figure></li></ul><p>测试下：<br>在python交互式窗口，<code>import MySQLdb</code>（注意：区分大小写）试试，不报错的话，就证明安装好了。<br>参考：<a href="http://www.cnblogs.com/coser/archive/2012/01/11/2319125.html" target="_blank" rel="noopener">ubuntu下mysql-python模块的安装</a></p><ul><li>修改mysite/settings.py，添加MySQL配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Database</span><br><span class="line"># https://docs.djangoproject.com/en/1.7/ref/settings/#databases</span><br><span class="line">#</span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        #&apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;,</span><br><span class="line">        #&apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;),</span><br><span class="line">&apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, # Add &apos;postgresql_psycopg2&apos;, &apos;mysql&apos;, &apos;sqlite3&apos; or &apos;oracle&apos;.</span><br><span class="line">        &apos;NAME&apos;: &apos;mysql&apos;, # 这里的名字一定要设为数据库名字否者会出现Unknown database &apos;xxx&apos;</span><br><span class="line">        # The following settings are not used with sqlite3:</span><br><span class="line">        &apos;USER&apos;: &apos;root&apos;,</span><br><span class="line">        &apos;PASSWORD&apos;: &apos;123&apos;,# 改为自己设置的密码</span><br><span class="line">        &apos;HOST&apos;: &apos;127.0.0.1&apos;,                      # Empty for localhost through domain sockets or &apos;127.0.0.1&apos; for localhost through TCP.</span><br><span class="line">        &apos;PORT&apos;: &apos;3306&apos;,                      # Set to empty string for default.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意，由于py文件默认用ASCII编码，如果有中文会出错，需要在文件的<strong>第一或第二行</strong>加入编码设置：<code># -*- coding: utf-8 -*-</code>。参考：<a href="http://blog.csdn.net/chenyulancn/article/details/7941588" target="_blank" rel="noopener">Python中文问题 或 SyntaxError: Non-ASCII character ‘\xe8’ in file</a><br>在python交互式窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.db import connection</span><br><span class="line">&gt;&gt;&gt; cursor = connection.cursor()</span><br></pre></td></tr></table></figure></p><p><code>django.db</code>注意区分大小写，不报错的话，就证明安装好了。<br>参考：<a href="http://www.cnblogs.com/wendoudou/p/mysql.html" target="_blank" rel="noopener">python Django 学习笔记（四）—— 使用MySQL数据库</a>、<a href="https://docs.djangoproject.com/en/1.7/ref/settings/#databases" target="_blank" rel="noopener">Django-settings-databases</a>、<a href="http://www.cnblogs.com/mutoulbj/archive/2012/04/08/2437698.html" target="_blank" rel="noopener">ubuntu下Django连接mysql数据库出错及解决</a></p><ul><li>创建app并测试数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># django-admin startapp firstapp # firstapp为新创建的app名称</span><br></pre></td></tr></table></figure></li></ul><p>运行上述命令会在mysite工程目录里创建一个firstapp目录。<br>然后在mystite/settings.py中的<code>INSTALLED_APPS</code>模块的最下面加入<code>firstapp</code>，安装此app：<br><img src="http://keke-hexo-blog.qiniudn.com/image/Django/mysite-settings-install-app.png" alt><br>编辑app的模块文件firstapp/models.py，填入操作数据库的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#vim: set fileencoding=utf-8 :</span><br><span class="line">#</span><br><span class="line">from django.db import models</span><br><span class="line">#</span><br><span class="line"># Create your models here.</span><br><span class="line">#</span><br><span class="line">class Company(models.Model):</span><br><span class="line">    full_name = models.CharField(u&apos;公司全称&apos; ,max_length=30)</span><br><span class="line">    address = models.CharField(u&apos;地址&apos;, max_length=50)</span><br><span class="line">    tel = models.CharField(u&apos;电话&apos;, max_length=15,blank=True)</span><br><span class="line"></span><br><span class="line">    def __unicode__(self):</span><br><span class="line">        return  &apos;%s %s %s&apos; % (self.full_name,self.address,self.tel)</span><br><span class="line">#</span><br><span class="line">class Product(models.Model):</span><br><span class="line">    product_name = models.CharField(u&apos;产品名称&apos;, max_length=30)</span><br><span class="line">    price = models.FloatField(u&apos;价格&apos;)</span><br><span class="line">    stock = models.IntegerField(u&apos;库存&apos;, max_length=5)</span><br><span class="line">    company = models.ForeignKey(Company)</span><br><span class="line">    create_date = models.DateField(u&apos;生产日期&apos;)</span><br><span class="line">#</span><br><span class="line">    def __unicode__(self):</span><br><span class="line">        return self.product_name</span><br><span class="line">    #设置一些与特定模型相关的选项</span><br><span class="line">    class Meta:</span><br><span class="line">        ordering = [&apos;create_date&apos;]</span><br></pre></td></tr></table></figure></p><p>采用 python manage.py validate 检查模型的语法和逻辑是否正确。<br>没有错误则执行 python manage.py syncdb创建数据表。<br>现在你可以看到你的数据库除了生成了products_company，products_product外还创建了其它好几个表，这些是django管理后台所需表暂不管。<br>参考：<a href="http://www.cnblogs.com/wendoudou/p/mysql.html" target="_blank" rel="noopener">python Django 学习笔记（四）—— 使用MySQL数据库</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Nginx </tag>
            
            <tag> MySQL </tag>
            
            <tag> uWSGI </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云ECS配置LNMPA服务器</title>
      <link href="/2014/11/27/configure-aliyun-ECS/"/>
      <url>/2014/11/27/configure-aliyun-ECS/</url>
      
        <content type="html"><![CDATA[<h2 id="购买阿里云ECS-aliyun-Elastic-Compute-Service"><a href="#购买阿里云ECS-aliyun-Elastic-Compute-Service" class="headerlink" title="购买阿里云ECS(aliyun Elastic Compute Service)"></a>购买阿里云ECS(aliyun Elastic Compute Service)</h2><blockquote><p>建议最初可以选择最低配置，因为后续升级也非常容易。参考：<a href="http://ninghao.net/blog/1368" target="_blank" rel="noopener">在阿里云 CentOS 服务器（ECS）上搭建 nginx + mysql + php-fpm 环境</a></p></blockquote><ul><li>操作系统建议选择Linux，资源占用低，网络性能好，不过是纯命令行的，如果不喜欢可以选择Windows；</li><li>建议选择比较流行的且较快的Ubuntu，版本建议选择最新的长期支持版本14.04，如果不习惯也可以选择CentOS；</li><li>一般情况下，Linux系统盘的20G够用了（可用18G），如果网站还要上传图片和音视频则需要购买数据盘；</li></ul><a id="more"></a><h2 id="安装LNMPA"><a href="#安装LNMPA" class="headerlink" title="安装LNMPA"></a>安装LNMPA</h2><blockquote><p>　　<strong>LNMPA是什么?</strong><br>　　也许大家对LAMP、LNMP比较熟悉，LAMP代表Linux下Apache、MySQL、PHP这种网站服务器架构；LNMP代表的是Linux下Nginx、MySQL、PHP这种网站服务器架构。LNMPA代表的是Linux下Nginx、MySQL、PHP、Apache这种网站服务器架构，是结合LAMP与LNMP各自的优点而产生的新的网站服务器架构。<br>　　<strong>我们为什么采用LNMPA这种架构?</strong><br>　　采用Linux、PHP、MySQL的优点我们不必多说。<br>Nginx是一个小巧而高效的Linux下的Web服务器软件，与Apache相比，消耗资源更少，支持的并发连接，更高的效率，反向代理功能效率高、静态文件处理快等。<br>Apache是一款老牌的Web服务器软件，在高并发时对队列的处理比FastCGI更成熟，Apache的mod_php效率比php-cgi更高且更稳定、对伪静态支持好，不需要转换、多用户多站点权限等方面有着更好的效果……<br>　　<strong>LNMPA这种架构有什么优势?</strong><br>　　LNMPA使用Nginx作为前端服务能够更快更及时的静态页面、js、图片等，当客户端请求访问动态页面时由Nginx的反向代理给Apache处理，Apache处理完再交予Nginx返回给客户端。<br>采用LNMPA能够更好的解决LNMP架构中由于PHP-FPM方面产生的502错误，同时能够为提供更安全的多用户多站点环境。</p></blockquote><h3 id="Windows登陆远程主机"><a href="#Windows登陆远程主机" class="headerlink" title="Windows登陆远程主机"></a>Windows登陆远程主机</h3><p>　　下载<a href="http://the.earth.li/~sgtatham/putty/0.63/x86/putty.zip" target="_blank" rel="noopener">Putty</a>解压并运行putty.exe，输入远程主机的公网IP，点击打开，输入账号（Linux为root）和密码登陆即可。</p><h3 id="首先安装LNMP：http-lnmp-org-install-html"><a href="#首先安装LNMP：http-lnmp-org-install-html" class="headerlink" title="首先安装LNMP：http://lnmp.org/install.html"></a>首先安装LNMP：<a href="http://lnmp.org/install.html" target="_blank" rel="noopener">http://lnmp.org/install.html</a></h3><ul><li><p>安装MySQL会询问是否安装InnoDB存储引擎，一般网站不需要，如果是做大数据处理的则需要安装。<br>参考：<a href="http://www.cnblogs.com/villion/archive/2009/07/09/1893762.html" target="_blank" rel="noopener">MySQL: InnoDB 还是 MyISAM?</a>、<a href="http://www.t369.net/news/shownews.asp?id=56" target="_blank" rel="noopener">Default storage engine设置</a></p></li><li><p>安装PHP的版本，推荐 5.3.28，性能有所提升，也是大势所趋：<br>参考：<a href="http://msn.shandian.biz/749.html" target="_blank" rel="noopener">PHP版本的选择5.2.17 5.3.27 5.3.28 5.4 5.5兼容性问题分析</a></p></li><li><p>MySQL版本选择，首次安装建议选择5.5，如果是5.1的没必要升级到5.5：</p><blockquote><p>在低并发情况下，MySQL5.1跟MySQL5.5性能持平，而实际应用中大部分并发数都低于10，因此绝大部分用户没有必要立即更换至5.5版本；<br>在高并发情况下，MySQL5.5的性能优势明显。<br>参考：<br><a href="http://www.mysqlab.net/blog/2011/02/mysql-5-5-vs-mysql-5-1-performance/" target="_blank" rel="noopener">MySQL5.5与MySQL5.1 性能(比较)对比测试—MySQL实验室</a><br><a href="http://blog.chinaunix.net/uid-20639775-id-3169246.html" target="_blank" rel="noopener">MYSQL5.5和MYSQL5.1性能对比</a><br><a href="http://linuxguest.blog.51cto.com/195664/746361/" target="_blank" rel="noopener">MySQL 4.1/5.0/5.1/5.5/5.6各版本的主要区别</a></p></blockquote></li></ul><blockquote><p>LNMP脚本就会自动安装编译Nginx、MySQL、PHP、phpMyAdmin、Zend Optimizer这几个软件。<br>安装时间可能会几十分钟到几个小时不等，主要是机器的配置网速等原因会造成影响。<br>安装完成后命令行提示：<br><img src="http://keke-hexo-blog.qiniudn.com/image/LNMPA/LNMP1.1安装完成.png" alt><br>在浏览器里输入公网IP可以看到默认页面：<br><img src="http://keke-hexo-blog.qiniudn.com/image/LNMPA/LNMP1.1安装成功后的默认页面.png" alt></p></blockquote><h3 id="然后安装Apache：http-lnmp-org-lnmpa-html"><a href="#然后安装Apache：http-lnmp-org-lnmpa-html" class="headerlink" title="然后安装Apache：http://lnmp.org/lnmpa.html"></a>然后安装Apache：<a href="http://lnmp.org/lnmpa.html" target="_blank" rel="noopener">http://lnmp.org/lnmpa.html</a></h3><blockquote><p><strong>注意：低于1G内存不建议使用LNMPA，升级到LNMPA后无法降回LNMP。</strong></p></blockquote><h3 id="启用-InnoDB（一键LNMP已安装InnoDB，只是没有启用）"><a href="#启用-InnoDB（一键LNMP已安装InnoDB，只是没有启用）" class="headerlink" title="启用 InnoDB（一键LNMP已安装InnoDB，只是没有启用）"></a>启用 InnoDB（一键LNMP已安装InnoDB，只是没有启用）</h3><p><code>/etc/init.d/mysql stop</code><br><code>vim /etc/my.cnf</code><br>将默认引擎改为InnoDB，并注释掉<code>loose-skip-innodb</code>：<br><img src="http://keke-hexo-blog.qiniudn.com/image/LNMPA/启用InnoDB1.png" alt><br><code>/etc/init.d/mysql start</code><br><img src="http://keke-hexo-blog.qiniudn.com/image/LNMPA/InnoDB已经启用.png" alt><br>参考：<a href="http://down.chinaz.com/server/201207/2090_1.htm" target="_blank" rel="noopener">MySql中启用InnoDB数据引擎的方法</a><br>如果没有安装InnoDB需要安装：<br><a href="http://blog.csdn.net/tenfyguo/article/details/7706534" target="_blank" rel="noopener">mysql中如何安装innodb plugin</a>、<a href="http://luoyahu.iteye.com/blog/838450" target="_blank" rel="noopener">mysql 安装innodb支持</a><br>MySQL命令：<a href="http://www.2cto.com/database/201209/154363.html" target="_blank" rel="noopener">MySQL命令行登录</a>、<a href="http://www.2cto.com/database/201209/154378.html" target="_blank" rel="noopener">MySQL数据库命令行工具</a></p><h3 id="LNMP状态管理命令"><a href="#LNMP状态管理命令" class="headerlink" title="LNMP状态管理命令"></a><a href="http://lnmp.org/faq/lnmp-status-manager.html" target="_blank" rel="noopener">LNMP状态管理命令</a></h3><p><em>LNMP状态管理命令：</em></p><p>LNMP状态管理： /root/lnmp {start|stop|reload|restart|kill|status}<br>Nginx状态管理：/etc/init.d/nginx {start|stop|reload|restart}<br>MySQL状态管理：/etc/init.d/mysql {start|stop|restart|reload|force-reload|status}<br>Memcached状态管理：/etc/init.d/memcached {start|stop|restart}<br>PHP-FPM状态管理：/etc/init.d/php-fpm {start|stop|quit|restart|reload|logrotate}<br>PureFTPd状态管理： /etc/init.d/pureftpd {start|stop|restart|kill|status}<br>ProFTPd状态管理： /etc/init.d/proftpd {start|stop|restart|reload}</p><p>如重启LNMP，输入命令：/root/lnmp restart 即可，单独重启mysql：/etc/init.d/mysql restart</p><p><em>LNMPA状态管理命令：</em></p><p>LNMPA状态管理： /root/lnmpa {start|stop|reload|restart|kill|status}<br>Nginx状态管理：/etc/init.d/nginx {start|stop|reload|restart}<br>MySQL状态管理：/etc/init.d/mysql {start|stop|restart|reload|force-reload|status}<br>Memcached状态管理：/etc/init.d/memcached {start|stop|restart}<br>PureFTPd状态管理： /etc/init.d/pureftpd {start|stop|restart|kill|status}<br>ProFTPd状态管理： /etc/init.d/proftpd {start|stop|restart|reload}<br>Apache状态管理：/etc/init.d/httpd {start|stop|restart|graceful|graceful-stop|configtest|status}</p><h2 id="挂载数据盘"><a href="#挂载数据盘" class="headerlink" title="挂载数据盘"></a>挂载数据盘</h2><p>购买的数据盘默认没有格式化和分区，需要手动操作：<a href="http://help.aliyun.com/view/13435365.html?spm=5176.7114037.1996646101.1.xaWFnH" target="_blank" rel="noopener">Linux 系统挂载数据盘</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Linux内存占用高的原因：<a href="http://www.vpser.net/other/linux-vps-ram.html" target="_blank" rel="noopener">Linux VPS内存占用那么多？- 解析Linux内存机制</a><br><img src="http://keke-hexo-blog.qiniudn.com/image/LNMPA/Linux内存占用.png" alt></p><p>Putty连接异常中断后如何注销其他用户：<a href="http://bbs.chinaunix.net/thread-1955574-1-1.html" target="_blank" rel="noopener">如何注销其他已登录的用户?</a><br><img src="http://keke-hexo-blog.qiniudn.com/image/LNMPA/注销其他用户.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 经验教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云 </tag>
            
            <tag> ECS </tag>
            
            <tag> LNMPA </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Nginx </tag>
            
            <tag> MySQL </tag>
            
            <tag> PHP </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（十二）—《QT学习之路2》摘录-10（数据库）</title>
      <link href="/2014/11/24/learn-qt-twelve/"/>
      <url>/2014/11/24/learn-qt-twelve/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2013/06/qt-study-road-2-database/" target="_blank" rel="noopener">Qt 学习之路 2（55）：数据库操作</a><blockquote><p>　　Qt 提供了 QtSql 模块来提供平台独立的基于 SQL 的数据库操作。这里我们所说的“平台独立”，既包括操作系统平台，有包括各个数据库平台。另外，我们强调了“基于 SQL”，因为 NoSQL 数据库至今没有一个通用查询方法，所以不可能提供一种通用的 NoSQL 数据库的操作。Qt 的数据库操作还可以很方便的与 model/view 架构进行整合。通常来说，我们对数据库的操作更多地在于对数据库表的操作，而这正是 model/view 架构的长项。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　Qt 使用QSqlDatabase表示一个数据库连接。更底层上，Qt 使用驱动（drivers）来与不同的数据库 API 进行交互。Qt 桌面版本提供了如下几种驱动：</p></blockquote><table><thead><tr><th>驱动</th><th>数据库</th></tr></thead><tbody><tr><td>QDB2</td><td>IBM DB2 (7.1 或更新版本)</td></tr><tr><td>QIBASE</td><td>Borland InterBase</td></tr><tr><td>QMYSQL</td><td>MySQL</td></tr><tr><td>QOCI</td><td>Oracle Call Interface Driver</td></tr><tr><td>QODBC</td><td>Open Database Connectivity (ODBC) – Microsoft SQL Server 及其它兼容 ODBC 的数据库</td></tr><tr><td>QPSQL</td><td>PostgreSQL (7.3 或更新版本)</td></tr><tr><td>QSQLITE2</td><td>SQLite 2</td></tr><tr><td>QSQLITE</td><td>SQLite 3</td></tr><tr><td>QSYMSQL</td><td>针对 Symbian 平台的SQLite 3</td></tr><tr><td>QTDS</td><td>Sybase Adaptive Server (自 Qt 4.7 起废除)</td></tr></tbody></table><blockquote><p>　　不过，由于受到协议的限制，Qt 开源版本并没有提供上面所有驱动的二进制版本，而仅仅以源代码的形式提供。通常，Qt 只默认搭载 QSqlite 驱动（这个驱动实际还包括 Sqlite 数据库，也就是说，如果需要使用 Sqlite 的话，只需要该驱动即可）。我们可以选择把这些驱动作为 Qt 的一部分进行编译，也可以当作插件编译。<br>　　如果习惯于使用 SQL 语句，我们可以选择QSqlQuery类；如果只需要使用高层次的数据库接口（不关心 SQL 语法），我们可以选择QSqlTableModel和QSqlRelationalTableModel。本章我们介绍QSqlQuery类，在后面的章节则介绍QSqlTableModel和QSqlRelationalTableModel。</p></blockquote><ul><li><a href="http://www.devbean.net/2013/06/qt-study-road-2-sql-model/" target="_blank" rel="noopener">Qt 学习之路 2（56）：使用模型操作数据库</a><blockquote><p>　　前一章我们使用 SQL 语句完成了对数据库的常规操作，包括简单的 CREATE、SELECT 等语句的使用。我们也提到过，Qt 不仅提供了这种使用 SQL 语句的方式，还提供了一种基于模型的更高级的处理方式。这种基于QSqlTableModel 的模型处理更为高级，如果对 SQL 语句不熟悉，并且不需要很多复杂的查询，这种QSqlTableModel模型基本可以满足一般的需求。本章我们将介绍QSqlTableModel的一般使用，对比 SQL 语句完成对数据库的增删改查等的操作。值得注意的是，QSqlTableModel并不一定非得结合 QListView或QTableView使用，我们完全可以用其作一般性处理。<br>　　————————————————————————–<br>　　另外需要注意，由于QSqlTableModel只是一种高级操作，肯定没有实际 SQL 语句方便。具体来说，我们使用QSqlTableModel只能进行 SELECT * 的查询，不能只查询其中某些列的数据。</p></blockquote></li></ul><p>＊ <a href="http://www.devbean.net/2013/06/qt-study-road-2-show-sql-data/" target="_blank" rel="noopener">Qt 学习之路 2（57）：可视化显示数据库数据</a></p><blockquote><p>　　前面我们用了两个章节介绍了 Qt 提供的两种操作数据库的方法。显然，使用QSqlQuery的方式更灵活，功能更强大，而使用QSqlTableModel则更简单，更方便与 model/view 结合使用（数据库应用很大一部分就是以表格形式显示出来，这正是 model/view 的强项）。本章我们简单介绍使用QSqlTableModel显示数据的方法。当然，我们也可以选择使用QSqlQuery获取数据，然后交给 view 显示，而这需要自己给 model 提供数据。鉴于我们前面已经详细介绍过如何使用自定义 model 以及如何使用QTableWidget，所以我们这里不再详细说明这一方法。</p></blockquote><ul><li><a href="http://www.devbean.net/2013/07/qt-study-road-2-edit-sql-fk/" target="_blank" rel="noopener">Qt 学习之路 2（58）：编辑数据库外键</a><blockquote><p>　　前面几章我们介绍了如何对数据库进行操作以及如何使用图形界面展示数据库数据。本章我们将介绍如何对数据库的数据进行编辑。当然，我们可以选择直接使用 SQL 语句进行更新，这一点同前面所说的 model/view 的编辑没有什么区别。除此之外，Qt 还为图形界面提供了更方便的展示并编辑的功能。<br>　　普通数据的编辑很简单，这里不再赘述。不过，我们通常会遇到多个表之间存在关联的情况。<br>　　————————————————————————–<br>　　注意外键部分：City 一列仅显示出了我们保存的外键。如果我们使用QSqlQuery，这些都不是问题，我们可以将外键信息放在一个 SQL 语句中 SELECT 出来。但是，我们不想使用QSqlQuery，那么现在可以使用另外的一个模型：QSqlRelationalTableModel。QSqlRelationalTableModel与QSqlTableModel十分类似，可以为一个数据库表提供可编辑的数据模型，同时带有外键的支持。<br>　　这段代码同前面的几乎一样。我们首先创建一个QSqlRelationalTableModel对象。注意，这里我们有一个setRelation()函数的调用。该语句说明，我们将第ColumnID_City列作为外键，参照于 city 表的 id 字段，使用 name 进行显示。另外的setItemDelegate()语句则提供了一种用于编辑外键的方式。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（十一）—《QT学习之路2》摘录-9（MVC）</title>
      <link href="/2014/11/23/learn-qt-eleven/"/>
      <url>/2014/11/23/learn-qt-eleven/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2013/01/qt-study-road-2-model-view/" target="_blank" rel="noopener"><code>***</code><strong>Qt 学习之路 2（41）：model/view 架构</strong></a><blockquote><p>　　有时，我们的系统需要显示大量数据，比如从数据库中读取数据，以自己的方式显示在自己的应用程序的界面中。早期的 Qt 要实现这个功能，需要定义一个组件，在这个组件中保存一个数据对象，比如一个列表。我们对这个列表进行查找、插入等的操作，或者把修改的地方写回，然后刷新组件进行显示。这个思路很简单，也很清晰，但是对于大型程序，这种设计就显得苍白无力。比如，在一个大型系统中，你的数据可能很大，全部存入一个组件的数据对象中，效率会很低，并且这样的设计也很难在不同组件之间共享数据。如果你要几个组件共享一个数据对象，要么你就要用存取函数公开这个数据对象，要么你就必须把这个数据对象放进不同的组件分别进行维护。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　Smalltalk 语言发明了一种崭新的实现，用来解决这个问题，这就是著名的 MVC 模型。对这个模型无需多言。MVC 是  Model-View-Controller 的简写，即模型-视图-控制器。在 MVC 中，模型负责获取需要显示的数据，并且存储这些数据的修改。每种数据类型都有它自己对应的模型，但是这些模型提供一个相同的 API，用于隐藏内部实现。视图用于将模型数据显示给用户。对于数量很大的数据，或许只显示一小部分，这样就能很好的提高性能。控制器是模型和视图之间的媒介，将用户的动作解析成对数据的操作，比如查找数据或者修改数据，然后转发给模型执行，最后再将模型中需要被显示的数据直接转发给视图进行显示。MVC 的核心思想是分层，不同的层应用不同的功能。<br>　　Qt 4 开始，引入了类似的 model/view 架构来处理数据和面向最终用户的显示之间的关系。当 MVC 的 V 和 C 结合在一起，我们就得到了 model/view 架构。这种架构依然将数据和界面分离，但是框架更为简单。同样，这种架构也允许使用不同界面显示同一数据，也能够在不改变数据的情况下添加新的显示界面。为了处理用户输入，我们还引入了委托（delegate）。引入委托的好处是，我们能够自定义数据项的渲染和编辑。<br>　　<img src="http://keke-hexo-blog.qiniudn.com/image/QT/model-view-overview.png" alt><br>　　如上图所示，模型与数据源进行交互，为框架中其它组件提供接口。这种交互的本质在于数据源的类型以及模型的实现方式。视图从模型获取模型索引，这种索引就是数据项的引用。通过将这个模型索引反向传给模型，视图又可以从数据源获取数据。在标准视图中，委托渲染数据项；在需要编辑数据时，委托使用直接模型索引直接与模型进行交互。<br>　　总的来说，model/view 架构将传统的 MV 模型分为三部分：模型、视图和委托。每一个组件都由一个抽象类定义，这个抽象类提供了基本的公共接口以及一些默认实现。模型、视图和委托则使用信号槽进行交互：<br>　　来自模型的信号通知视图，其底层维护的数据发生了改变；<br>　　来自视图的信号提供了有关用户与界面进行交互的信息；<br>　　来自委托的信号在用户编辑数据项时使用，用于告知模型和视图编辑器的状态。</p></blockquote><ul><li><a href="http://www.devbean.net/2013/02/qt-study-road-2-qlistwidget-qtreewidget-qtablewidget/" target="_blank" rel="noopener">Qt 学习之路 2（42）：QListWidget、QTreeWidget 和 QTableWidget</a><blockquote><p>　　<strong>QTableWidget</strong><br>　　我们要介绍的最后一个是 QTableWidget。QTableWidget并不比前面的两个复杂到哪里去，这点我们可以从代码看出来：</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QTableWidget tableWidget;</span><br><span class="line">tableWidget.setColumnCount(3);</span><br><span class="line">tableWidget.setRowCount(5);</span><br><span class="line"></span><br><span class="line">QStringList headers;</span><br><span class="line">headers &lt;&lt; &quot;ID&quot; &lt;&lt; &quot;Name&quot; &lt;&lt; &quot;Age&quot; &lt;&lt; &quot;Sex&quot;;</span><br><span class="line">tableWidget.setHorizontalHeaderLabels(headers);</span><br><span class="line"></span><br><span class="line">tableWidget.setItem(0, 0, new QTableWidgetItem(QString(&quot;0001&quot;)));</span><br><span class="line">tableWidget.setItem(1, 0, new QTableWidgetItem(QString(&quot;0002&quot;)));</span><br><span class="line">tableWidget.setItem(2, 0, new QTableWidgetItem(QString(&quot;0003&quot;)));</span><br><span class="line">tableWidget.setItem(3, 0, new QTableWidgetItem(QString(&quot;0004&quot;)));</span><br><span class="line">tableWidget.setItem(4, 0, new QTableWidgetItem(QString(&quot;0005&quot;)));</span><br><span class="line">tableWidget.setItem(0, 1, new QTableWidgetItem(QString(&quot;20100112&quot;)));</span><br><span class="line"></span><br><span class="line">tableWidget.show();</span><br></pre></td></tr></table></figure><blockquote><p>　　首先我们创建了QTableWidget对象，然后设置列数和行数。接下来使用一个QStringList，设置每一列的标题。我们可以通过调用setItem()函数来设置表格的单元格的数据。这个函数前两个参数分别是行索引和列索引，这两个值都是从 0 开始的，第三个参数则是一个QTableWidgetItem对象。Qt 会将这个对象放在第 row 行第 col 列的单元格中。有关QTableWidgetItem的介绍完全可以参见上面的QListWidgetItem和QTreeWidgetItem。</p></blockquote><ul><li><p><a href="http://www.devbean.net/2013/02/qt-study-road-2-qstringlistmodel/" target="_blank" rel="noopener">Qt 学习之路 2（43）：QStringListModel</a></p></li><li><p><a href="http://www.devbean.net/2013/02/qt-study-road-2-qfilesystemmodel/" target="_blank" rel="noopener">Qt 学习之路 2（44）：QFileSystemModel</a></p></li><li><p><a href="http://www.devbean.net/2013/02/qt-study-road-2-model/" target="_blank" rel="noopener"><code>***</code><strong>Qt 学习之路 2（45）：模型</strong></a></p><blockquote><p>　　在 model/view 架构中，model 提供一种标准接口，供视图和委托访问数据。在 Qt 中，这个接口由QAbstractItemModel类进行定义。不管底层数据是如何存储的，只要是QAbstractItemModel的子类，都提供一种表格形式的层次结构。视图利用统一的转换来访问模型中的数据。但是，需要提供的是，尽管模型内部是这样组织数据的，但是并不要求也得这样子向用户展示数据。<br>　　————————————————————————–<br>　　为了能够使得数据的显示同存储分离，我们引入模型索引（model index）的概念。通过索引，我们可以访问模型的特定元素的特定部分。视图和委托使用索引来请求所需要的数据。由此可以看出，只有模型自己需要知道如何获得数据，模型所管理的数据类型可以使用通用的方式进行定义。索引保存有创建的它的那个模型的指针，这使得同时操作多个模型成为可能。<br>　　————————————————————————–<br>　　模型索引提供了所需要的信息的<strong>临时索引</strong>，可以用于通过模型取回或者修改数据。由于模型随时可能重新组织其内部的结构，因此模型索引很可能变成不可用的，此时，就不应该保存这些数据。如果你需要长期有效的数据片段，必须创建<strong>持久索引</strong>。持久索引保证其引用的数据及时更新。临时索引（也就是通常使用的索引）由<code>QModelIndex</code>类提供，持久索引则是<code>QPersistentModelIndex</code>类。<br>　　————————————————————————–<br>　　总结一下：<br>　　　模型使用索引来提供给视图和委托有关数据项的位置的信息，这样做的好处是，模型之外的对象无需知道底层的数据存储方式；<br>　　　数据项通过行号、列号以及父项三个坐标进行定位；<br>　　　模型索引由模型在其它组件（视图和委托）请求时才会被创建；<br>　　　如果使用index()函数请求获得一个父项的可用索引，该索引会指向模型中这个父项下面的数据项。这个索引指向该项的一个子项；如果使用index()函数请求获得一个父项的不可用索引，该索引指向模型的最顶级项；<br>　　　角色用于区分数据项的不同类型的数据。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/03/qt-study-road-2-view-delegate/" target="_blank" rel="noopener"><code>***</code><strong>Qt 学习之路 2（46）：视图和委托</strong></a></p><blockquote><p>　　前面我们介绍了模型的概念。下面则是另外一个基本元素：视图。在 model/view 架构中，视图是数据从模型到最终用户的途径。数据通过视图向用户进行显示。此时，这种显示方式不必须同模型的存储结构相一致。实际上，很多情况下，数据的显示同底层数据的存储是完全不同的。<br>　　我们使用QAbstractItemModel提供标准的模型接口，使用 QAbstractItemView提供标准的视图接口，而结合这两者，就可以将数据同表现层分离，在视图中利用前面所说的模型索引。视图管理来自模型的数据的布局：既可以直接渲染数据本身，也可以通过委托渲染和编辑数据。<br>　　视图不仅仅用于展示数据，还用于在数据项之间的导航以及数据项的选择。另外，视图也需要支持很多基本的用户界面的特性，例如右键菜单以及拖放。视图可以提供数据编辑功能，也可以将这种编辑功能交由某个委托完成。视图可以脱离模型创建，但是在其进行显示之前，必须存在一个模型。也就是说，视图的显示是完全基于模型的，这是不能脱离模型存在的。对于用户的选择，多个视图可以相互独立，也可以进行共享。<br>　　某些视图，例如QTableView和QTreeView，不仅显示数据，还会显示列头或者表头。这些是由QHeaderView视图类提供的。在《QFileSystemModel》一章的最后，我们曾经提到过这个问题。表头通常访问视图所包含的同一模型。它们使用QAbstractItemModel::headerData()函数从模型中获取数据，然后将其以标签 label 的形式显示出来。我们可以通过继承QHeaderView类，实现某些更特殊的功能。<br>　　————————————————————————–<br>　　正如前面的章节介绍的，我们通常会为<strong>视图</strong>提供一个<strong>模型</strong>。<br>　　跟我们前面的演示几乎一模一样。现在我们有一个问题：如果我们双击某一行，列表会允许我们进行编辑。但是，我们没办法控制用户只能输入数字——当然，我们可以在提交数据时进行检测，这也是一种办法，不过，更友好的方法是，根本不允许用户输入非法字符。为了达到这一目的，我们使用了<strong>委托</strong>。<br>　　————————————————————————–<br>　　正如前面所说，委托就是供视图实现某种高级的编辑功能。不同于经典的 Model-View-Controller（MVC）模式，model/view 没有将用户交互部分完全分离。一般地，视图将数据向用户进行展示并且处理通用的输入。但是，对于某些特殊要求（比如这里的要求必须输入数字），则交予委托完成。这些组件提供输入功能，同时也能渲染某些特殊数据项。委托的接口由QAbstractItemDelegate定义。在这个类中，委托通过paint()和sizeHint()两个函数渲染用户内容（也就是说，你必须自己将渲染器绘制出来）。为使用方便，从 4.4 开始，Qt 提供了另外的基于组件的子类：QItemDelegate和QStyledItemDelegate。默认的委托是QStyledItemDelegate。二者的区别在于绘制和向视图提供编辑器的方式。QStyledItemDelegate使用当前样式绘制，并且能够使用 Qt Style Sheet（我们会在后面的章节对 QSS 进行介绍），因此我们推荐在自定义委托时，使用QStyledItemDelegate作为基类。不过，除非自定义委托需要自己进行绘制，否则，二者的代码其实是一样的。<br>　　继承QStyledItemDelegate需要实现以下几个函数：<br>　　createEditor()：返回一个组件。该组件会被作为用户编辑数据时所使用的编辑器，从模型中接受数据，返回用户修改的数据。<br>　　setEditorData()：提供上述组件在显示时所需要的默认值。<br>　　updateEditorGeometry()：确保上述组件作为编辑器时能够完整地显示出来。<br>　　setModelData()：返回给模型用户修改过的数据。<br>　　————————————————————————–<br>　　在用户编辑完数据后，委托会调用setModelData()函数将新的数据保存到模型中。因此，在这里我们首先获取QSpinBox实例，得到用户输入值，然后设置到模型相应的位置。<strong>标准的QStyledItemDelegate类会在完成编辑时发出closeEditor()信号，视图会保证编辑器已经关闭并且销毁，因此无需对内存进行管理。</strong>由于我们的处理很简单，无需在发出closeEditor()信号，但是在复杂的实现中，记得可以在这里发出这个信号。针对数据的任何操作都必须提交给QAbstractItemModel，这使得委托独立于特定的视图。当然，在真实应用中，我们需要检测用户的输入是否合法，是否能够存入模型。<br>　　————————————————————————–<br>　　值得注意的是，new 操作符并不会真的创建编辑器实例。相反，只有在真正需要时，Qt 才会生成一个编辑器实例。这保证了程序运行时的性能。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/03/qt-study-road-2-view-selection/" target="_blank" rel="noopener">Qt 学习之路 2（47）：视图选择</a></p><blockquote><p>　　选择是视图中常用的一个操作。在列表、树或者表格中，通过鼠标点击可以选中某一项，被选中项会变成高亮或者反色。在 Qt 中，选择也是使用了一种模型。在 model/view 架构中，这种选择模型提供了一种更通用的对选择操作的描述。对于一般应用而言，Qt 内置的选择模型已经足够，但是，Qt 还是允许你创建自己的选择模型，来实现一些特殊的操作。<br>　　Qt 使用QItemSelectionModel类获取视图中项目的选择情况。这个模型保持有项目的索引，并且独立于任何视图。这意味着，我们可以让不同的视图共享同一个选择模型，从来达到一种同步操作的目的。选择由选择区域组成。模型只将选区的开始和结束的索引位置记录下来，以保证对于很大的选区也有很好的性能。非连续选区则由多个连续选择组成。<br>　　选择会直接应用于选择模型所维护的那些被选中的索引上面。最新的选择就是当前选择。这意味着，即便界面上没有显示有任何项目被选择，如果通过某些命令对选区进行操作，同样会有作用。<br>　　在视图中，始终存在一个当前项和被选择项（即便从界面上看不到有任何选择）。与通常所想的不同，当前项和选择项是相互独立的两个状态。一个项目可以即是当前项又是选择项。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/04/qt-study-road-2-qsortfilterproxymodel/" target="_blank" rel="noopener">Qt 学习之路 2（48）：QSortFilterProxyModel</a></p><blockquote><p>　　从本章开始，我们将逐步了解有关自定义模型的相关内容。尽管前面我们曾经介绍过 Qt 提供的几个内置模型：QStringListModel和QFileSystemModel，但对于千变万化的需求而言，这些显然是远远不够的。于是，Qt 也允许我们对模型进行自定义。<br>　　在正式开始介绍自定义模形之前，我们先来了解一个新的类：QSortFilterProxyModel。之所以将这个类放在这里，是因为在一定程序上，我们可以使用QSortFilterProxyModel获得一些可能必须自定义才能达到的效果。QSortFilterProxyModel并不能单独使用。顾名思义，它是一个“代理”，其真正的数据需要另外的一个模型提供。它的作用是对数据进行排序和过滤。排序很好理解，而过滤，则是按照输入的内容对数据及进行筛选，很像 Excel 里面的过滤器。不过 Qt 提供的过滤功能是基于正则表达式的，功能很强大。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/05/qt-study-road-2-custom-readonly-model/" target="_blank" rel="noopener">Qt 学习之路 2（49）：自定义只读模型</a></p><blockquote><p>　　model/view 模型将数据与视图分割开来，也就是说，我们可以为不同的视图，QListView、QTableView和QTreeView提供一个数据模型，这样我们可以从不同角度来展示数据的方方面面。但是，面对变化万千的需求，Qt 预定义的几个模型是远远不能满足需要的。因此，我们还必须自定义模型。<br>　　类似QAbstractView类之于自定义视图，QAbstractItemModel 为自定义模型提供了一个足够灵活的接口。它能够支持数据源的层次结构，能够对数据进行增删改操作，还能够支持拖放。不过，有时候一个灵活的类往往显得过于复杂，所以，Qt 又提供了QAbstarctListModel和QAbstractTableModel两个类来简化非层次数据模型的开发。顾名思义，这两个类更适合于结合列表和表格使用。<br>　　本节，我们正式开始对自定义模型进行介绍。<br>　　在开始自定义模型之前，我们首先需要思考这样一个问题：我们的数据结构适合于哪种视图的显示方式？是列表，还是表格，还是树？如果我们的数据仅仅用于列表或表格的显示，那么QAbstractListModel或者QAbstractTableModel 已经足够，它们为我们实现了很多默认函数。但是，如果我们的数据具有层次结构，并且必须向用户显示这种层次，我们只能选择QAbstractItemModel。不管底层数据结构是怎样的格式，最好都要直接考虑适应于标准的QAbstractItemModel的接口，这样就可以让更多视图能够轻松访问到这个模型。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/05/qt-study-road-2-custom-editable-model/" target="_blank" rel="noopener">Qt 学习之路 2（50）：自定义可编辑模型</a></p><blockquote><p>　　上一章我们了解了如何自定义只读模型。顾名思义，只读模型只能够用于展示只读数据，用户不能对其进行修改。如果允许用户修改数据，则应该提供可编译的模型。可编辑模型与只读模型非常相似，至少在展示数据方面几乎是完全一样的，所不同的是可编译模型需要提供用户编辑数据后，应当如何将数据保存到实际存储值中。<br>　　我们还是利用上一章的CurrencyModel，在此基础上进行修改。相同的代码这里不再赘述，我们只列出增加以及修改的代码。相比只读模型，可编辑模型需要增加以下两个函数的实现：<br>　　<code>Qt::ItemFlags flags(const QModelIndex &amp;index) const;</code><br>　　<code>bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role = Qt::EditRole);</code><br>　　还记得之前我们曾经介绍过，在 Qt 的 model/view 模型中，我们使用委托 delegate 来实现数据的编辑。在实际创建编辑器之前，委托需要检测这个数据项是不是允许编辑。模型必须让委托知道这一点，这是通过返回模型中每个数据项的标记 flag 来实现的，也就是这个 flags() 函数。<br>　　————————————————————————–<br>　　当我们完成以上工作时，还需要修改一下data()函数。<br>　　我们的修改很简单：仅仅是增加了role == Qt::EditRole这么一行判断。这意味着，当是EditRole时，Qt 会提供一个默认值。我们可以试着删除这个判断来看看其产生的效果。<br>　　最后运行一下程序，修改一下数据就会发现，当我们修改过一个单元格后，Qt 会自动刷新所有受影响的数据的值。这也正是 model / view 模型的强大之处：对数据模型的修改会直接反映到视图上。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/05/qt-study-road-2-bool-tree-model/" target="_blank" rel="noopener">Qt 学习之路 2（51）：布尔表达式树模型</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（十）—《QT学习之路2》摘录-8（进程和线程）</title>
      <link href="/2014/11/23/learn-qt-ten/"/>
      <url>/2014/11/23/learn-qt-ten/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2013/11/qt-study-road-2-process/" target="_blank" rel="noopener">Qt 学习之路 2（69）：进程 - <strong>QProcess</strong></a><blockquote><p>　　注意，我们可以在上面的程序中找到这个命令的每一个字符。事实上，我们可以把一个进程看做执行了一段命令（在 Windows 平台就是控制台命令；在 Linux 平台（包括 Unix）则是执行一个普通的命令，比如 ls）。我们的程序相当于执行了 dir 命令，其参数是 C:\，这是由arguments数组决定的（至于为什么我们需要将 dir 命令作为参数传递给 cmd.exe，这是由于 Windows 平台的规定。在 Windows 中，dir 命令并不是一个独立的可执行程序，而是通过 cmd.exe 进行解释；这与 ls 在 Linux 中的地位不同，在 Linux 中，ls 就是一个可执行程序。因此如果你需要在 Linux 中执行 ls，那么program的值应该就是 ls ）。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　—————————————————————————<br>　　为了开启进程，我们将外部程序名字（program）和程序启动参数（arguments）作为参数传给QProcess::start()函数。当然，你也可以使用setProgram()和setArguments()进行设置。此时，QProcess进入Starting 状态；当程序开始执行之后，QProcess进入Running 状态，并且发出started()信号。当进程退出时，QProcess进入NotRunning状态（也是初始状态），并且发出finished()信号。finished()信号以参数的形式提供进程的退出代码和退出状态。如果发送错误，QProcess会发出error()信号<br>　　QProcess允许你将一个进程当做一个顺序访问的 I/O 设备。我们可以使用write()函数将数据提供给进程的标准输入；使用read()、readLine()或者getChar()函数获取其标准输出。由于QProcess继承自QIODevice，因此QProcess也可以作为QXmlReader的输入或者直接使用QNetworkAccessManager将其生成的数据上传到网络。<br>　　进程通常有两个预定义的通道：标准输出通道（stdout）和标准错误通道（stderr）。前者就是常规控制台的输出，后者则是由进程输出的错误信息。这两个通道都是独立的数据流，我们可以通过使用setReadChannel()函数来切换这两个通道。当进程的当前通道可用时，QProcess会发出readReady()信号。当有了新的标准输出数据时，QProcess会发出readyReadStandardOutput()信号；当有了新的标准错误数据时，则会发出readyReadStandardError()信号。我们前面的示例程序就是使用了readReady()信号。注意，由于我们是运行在 Windows 平台，Windows 控制台的默认编码是 GBK，为了避免出现乱码，我们必须设置文本的编码方式。<br>　　通道的术语可能会引起误会。注意，进程的输出通道对应着QProcess的 读 通道，进程的输入通道对应着QProcess的 写 通道。这是因为我们使用QProcess“读取”进程的输出，而我们针对QProcess的“写入”则成为进程的输入。QProcess还可以合并标准输出和标准错误通道，使用setProcessChannelMode()函数设置MergedChannels即可实现。<br>　　另外，QProcess还允许我们使用setEnvironment()为进程设置环境变量，或者使用setWorkingDirectory()为进程设置工作目录。<br>　　前面我们所说的信号槽机制，类似于前面我们介绍的QNetworkAccessManager，都是异步的。与QNetworkAccessManager不同在于，QProcess提供了同步函数：<br>　　　waitForStarted()：阻塞到进程开始；<br>　　　waitForReadyRead()：阻塞到可以从进程的当前读通道读取新的数据；<br>　　　waitForBytesWritten()：阻塞到数据写入进程；<br>　　　waitForFinished()：阻塞到进程结束；<br>　　注意，在主线程（调用了QApplication::exec()的线程）调用上面几个函数会让界面失去响应。</p></blockquote><ul><li><p><a href="http://www.devbean.net/2013/11/qt-study-road-2-ipc/" target="_blank" rel="noopener">Qt 学习之路 2（70）：进程间通信 - <strong>QSharedMemory</strong></a></p><blockquote><p>　　上一章我们了解了有关进程的基本知识。我们将进程理解为相互独立的正在运行的程序。由于二者是相互独立的，就存在交互的可能性，也就是我们所说的进程间通信（Inter-Process Communication，IPC）。不过也正因此，我们的一些简单的交互方式，比如普通的信号槽机制等，并不适用于进程间的相互通信。我们说过，进程是操作系统的基本调度单元，因此，进程间交互不可避免与操作系统的实现息息相关。<br>　　Qt 提供了四种进程间通信的方式：<br>　　　使用共享内存（shared memory）交互：这是 Qt 提供的一种各个平台均有支持的进程间交互的方式。<br>　　　TCP/IP：其基本思想就是将同一机器上面的两个进程一个当做服务器，一个当做客户端，二者通过网络协议进行交互。除了两个进程是在同一台机器上，这种交互方式与普通的 C/S 程序没有本质区别。Qt 提供了 QNetworkAccessManager 对此进行支持。<br>　　　D-Bus：freedesktop 组织开发的一种低开销、低延迟的 IPC 实现。Qt 提供了 QtDBus 模块，把信号槽机制扩展到进程级别（因此我们前面强调是“普通的”信号槽机制无法实现 IPC），使得开发者可以在一个进程中发出信号，由其它进程的槽函数响应信号。<br>　　　QCOP（Qt COmmunication Protocol）：QCOP 是 Qt 内部的一种通信协议，用于不同的客户端之间在同一地址空间内部或者不同的进程之间的通信。目前，这种机制只用于 Qt for Embedded Linux 版本。<br>　　从上面的介绍中可以看到，通用的 IPC 实现大致只有共享内存和 TCP/IP 两种。后者我们前面已经大致介绍过（应用程序级别的 QNetworkAccessManager 或者更底层的 QTcpSocket 等）；本章我们主要介绍前者。<br>　　Qt 使用QSharedMemory类操作共享内存段。我们可以把QSharedMemory看做一种指针，这种指针指向分配出来的一个共享内存段。而这个共享内存段是由底层的操作系统提供，可以供多个线程或进程使用。因此，QSharedMemory可以看做是专供 Qt 程序访问这个共享内存段的指针。同时，QSharedMemory还提供了单一线程或进程互斥访问某一内存区域的能力。当我们创建了QSharedMemory实例后，可以使用其create()函数请求操作系统分配一个共享内存段。如果创建成功（函数返回true），Qt 会自动将系统分配的共享内存段连接（attach）到本进程。<br>　　前面我们说过，IPC 离不开平台特性。作为 IPC 的实现之一的共享内存也遵循这一原则。有关共享内存段，各个平台的实现也有所不同：<br>　　　Windows：QSharedMemory不“拥有”共享内存段。当使用了共享内存段的所有线程或进程中的某一个销毁了QSharedMemory实例，或者所有的都退出，Windows 内核会自动释放共享内存段。<br>　　　Unix：QSharedMemory“拥有”共享内存段。当最后一个线程或进程同共享内存分离，并且调用了QSharedMemory的析构函数之后，Unix 内核会将共享内存段释放。注意，这里与 Windows 不同之处在于，如果使用了共享内存段的线程或进程没有调用QSharedMemory的析构函数，程序将会崩溃。<br>　　　HP-UX：每个进程只允许连接到一个共享内存段。这意味着在 HP-UX 平台，QSharedMemory不应被多个线程使用。<br>　 　—————————————————————————<br>　 　注意，如果某个共享内存段不是由 Qt 创建的，我们也是可以在 Qt 应用程序中使用。不过这种情况下我们必须使用QSharedMemory::setNativeKey()来设置共享内存段。使用原始键（native key）时，QSharedMemory::lock()函数就会失效，我们必须自己保护共享内存段不会在多线程或进程访问时出现问题。<br>　 　IPC 使用共享内存通信是一个很常用的开发方法。多个进程间得通信要比多线程间得通信少一些，不过在某一族的应用情形下，比如 QQ 与 QQ 音乐、QQ 影音等共享用户头像，还是非常有用的。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/11/qt-study-road-2-thread-intro/" target="_blank" rel="noopener">Qt 学习之路 2（71）：线程简介 - <strong>QThread</strong></a></p><blockquote><p>　 　前面我们讨论了有关进程以及进程间通讯的相关问题，现在我们开始讨论线程。事实上，现代的程序中，使用线程的概率应该大于进程。特别是在多核时代，随着 CPU 主频的提升，受制于发热量的限制，CPU 散热问题已经进入瓶颈，另辟蹊径地提高程序运行效率就是使用线程，充分利用多核的优势。有关线程和进程的区别已经超出了本章的范畴，我们简单提一句，一个进程可以有一个或更多线程同时运行。线程可以看做是“轻量级进程”，进程完全由操作系统管理，线程即可以由操作系统管理，也可以由应用程序管理。<br>　 　—————————————————————————<br>　 　有经验的开发者立即指出，这里需要使用线程。这是因为 Qt 中所有界面都是在 UI 线程中（也被称为主线程，就是执行了QApplication::exec()的线程），在这个线程中执行耗时的操作（比如那个循环），就会阻塞 UI 线程，从而让界面停止响应。界面停止响应，用户体验自然不好，不过更严重的是，有些窗口管理程序会检测到你的程序已经失去响应，可能会建议用户强制停止程序，这样一来你的程序可能就此终止，任务再也无法完成。所以，为了避免这一问题，我们要使用 QThread 开启一个新的线程。<br>　 　—————————————————————————<br>　 　<strong>注意，我们增加了一个WorkerThread类。WorkerThread继承自QThread类，重写了其run()函数。我们可以认为，run()函数就是新的线程需要执行的代码。</strong>在这里就是要执行这个循环，然后发出计算完成的信号。而在按钮点击的槽函数中，使用QThread::start()函数启动一个线程（注意，这里不是run()函数）。再次运行程序，你会发现现在界面已经不会被阻塞了。另外，我们将WorkerThread::deleteLater()函数与WorkerThread::finished()信号连接起来，当线程完成时，系统可以帮我们清除线程实例。这里的finished()信号是系统发出的，与我们自定义的done()信号无关。<br>　 　<strong>这是 Qt 线程的最基本的使用方式之一（确切的说，这种使用已经不大推荐使用，不过因为看起来很清晰，而且简单使用起来也没有什么问题，所以还是有必要介绍）。代码看起来很简单，不过，如果你认为 Qt 的多线程编程也很简单，那就大错特错了。Qt 多线程的优势设计使得它使用起来变得容易，但是坑很多，稍不留神就会被绊住，尤其是涉及到与 QObject 交互的情况。稍懂多线程开发的童鞋都会知道，调试多线程开发简直就是煎熬。</strong>下面几章，我们会更详细介绍有关多线程编程的相关内容。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/11/qt-study-road-2-thread-and-event-loop/" target="_blank" rel="noopener"><code>***</code><strong>Qt 学习之路 2（72）：线程和事件循环</strong></a></p><blockquote><p>　　前面一章我们简单介绍了如何使用QThread实现线程。现在我们开始详细介绍如何“正确”编写多线程程序。我们这里的大部分内容来自于Qt的<a href="http://qt-project.org/wiki/Threads_Events_QObjects" target="_blank" rel="noopener">一篇Wiki文档</a>，有兴趣的童鞋可以去看原文。<br>　　在介绍在以前，我们要认识两个术语：<br>　　　可重入的（Reentrant）：如果多个线程可以在同一时刻调用一个类的所有函数，并且保证每一次函数调用都引用一个唯一的数据，就称这个类是可重入的（Reentrant means that all the functions in the referenced class can be called simultaneously by multiple threads, provided that each invocation of the functions reference unique data.）。大多数 C++ 类都是可重入的。类似的，一个函数被称为可重入的，如果该函数允许多个线程在同一时刻调用，而每一次的调用都只能使用其独有的数据。全局变量就不是函数独有的数据，而是共享的。换句话说，这意味着类或者函数的使用者必须使用某种额外的机制（比如锁）来控制对对象的实例或共享数据的序列化访问。<br>　　　线程安全（Thread-safe）：如果多个线程可以在同一时刻调用一个类的所有函数，即使每一次函数调用都引用一个共享的数据，就说这个类是线程安全的（Threadsafe means that all the functions in the referenced class can be called simultaneously by multiple threads even when each invocation references shared data.）。如果多个线程可以在同一时刻访问函数的共享数据，就称这个函数是线程安全的。<br>　　<strong>进一步说，对于一个类，如果不同的实例可以被不同线程同时使用而不受影响，就说这个类是可重入的；如果这个类的所有成员函数都可以被不同线程同时调用而不受影响，即使这些调用针对同一个对象，那么我们就说这个类是线程安全的。由此可以看出，线程安全的语义要强于可重入。</strong>接下来，我们从事件开始讨论。之前我们说过，Qt 是事件驱动的。在 Qt 中，事件由一个普通对象表示（QEvent或其子类）。<strong>这是事件与信号的一个很大区别：事件总是由某一种类型的对象表示，针对某一个特殊的对象，而信号则没有这种目标对象。</strong>所有QObject的子类都可以通过覆盖QObject::event()函数来控制事件的对象。<br>　　事件可以由程序生成，也可以在程序外部生成。例如：<br>　　　QKeyEvent和QMouseEvent对象表示键盘或鼠标的交互，通常由系统的窗口管理器产生；<br>　　　QTimerEvent事件在定时器超时时发送给一个QObject，定时器事件通常由操作系统发出；<br>　　　QChildEvent在增加或删除子对象时发送给一个QObject，这是由 Qt 应用程序自己发出的。<br>　  需要注意的是，与信号不同，事件并不是一产生就被分发。事件产生之后被加入到一个队列中（这里的队列含义同数据结构中的概念，先进先出），该队列即被称为事件队列。事件分发器遍历事件队列，如果发现事件队列中有事件，那么就把这个事件发送给它的目标对象。这个循环被称作事件循环。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/11/qt-study-road-2-thread-related-classes/" target="_blank" rel="noopener">Qt 学习之路 2（73）：Qt 线程相关类</a></p><blockquote><p>　　QThread是我们将要详细介绍的第一个类。它也是 Qt 线程类中最核心的底层类。由于 Qt 的跨平台特性，QThread要隐藏掉所有平台相关的代码。<br>　　QRunnable是我们要介绍的第二个类。这是一个轻量级的抽象类，用于开始一个另外线程的任务。这种任务是运行过后就丢弃的。由于这个类是抽象类，我们需要继承QRunnable，然后重写其纯虚函数QRunnable::run()。<br>　　QtConcurrent是我们要介绍的最后一个对象。这是一个高级 API，构建于QThreadPool之上，用于处理大多数通用的并行计算模式：map、reduce 以及 filter。它还提供了QtConcurrent::run()函数，用于在另外的线程运行一个函数。注意，QtConcurrent是一个命名空间而不是一个类，因此其中的所有函数都是命名空间内的全局函数。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/12/qt-study-road-2-thread-and-qobject/" target="_blank" rel="noopener"><code>***</code><strong>Qt 学习之路 2（74）：线程和 QObject</strong></a></p><blockquote><p>　  前面两个章节我们从事件循环和线程类库两个角度阐述有关线程的问题。本章我们将深入线程间得交互，探讨线程和QObject之间的关系。在某种程度上，这才是多线程编程真正需要注意的问题。<br>　  现在我们已经讨论过事件循环。我们说，每一个 Qt 应用程序至少有一个事件循环，就是调用了QCoreApplication::exec()的那个事件循环。不过，QThread也可以开启事件循环。只不过这是一个受限于线程内部的事件循环。因此我们将处于调用main()函数的那个线程，并且由QCoreApplication::exec()创建开启的那个事件循环成为主事件循环，或者直接叫主循环。<strong>注意，QCoreApplication::exec()只能在调用main()函数的线程调用。主循环所在的线程就是主线程，也被成为 GUI 线程，因为所有有关 GUI 的操作都必须在这个线程进行。QThread的局部事件循环则可以通过在QThread::run()中调用QThread::exec()开启。</strong><br>　  —————————————————————————<br>　  我们可以通过调用QObject::thread()可以查询一个QObject的线程依附性。注意，在QCoreApplication对象之前创建的QObject没有所谓线程依附性，因此也就没有对象为其派发事件。也就是说，实际是QCoreApplication创建了代表主线程的QThread对象。<br>　  —————————————————————————<br>　  值得注意的一点是，QObject及其所有子类都不是线程安全的（但都是可重入的）。因此，你不能有两个线程同时访问一个QObject对象，除非这个对象的内部数据都已经很好地序列化（例如为每个数据访问加锁）。记住，在你从另外的线程访问一个对象时，它可能正在处理所在线程的事件循环派发的事件！基于同样的原因，你也不能在另外的线程直接delete一个QObject对象，相反，你需要调用QObject::deleteLater()函数，这个函数会给对象所在线程发送一个删除的事件。<br>　  此外，QWidget及其子类，以及所有其它 GUI 相关类（即便不是QObject的子类，例如QPixmap），甚至不是可重入的：它们只能在 GUI 线程访问。<br>　  QObject的线程依附性是可以改变的，方法是调用QObject::moveToThread()函数。该函数会改变一个对象及其所有子对象的线程依附性。由于QObject不是线程安全的，所以我们只能在该对象所在线程上调用这个函数。也就是说，我们只能在对象所在线程将这个对象移动到另外的线程，不能在另外的线程改变对象的线程依附性。还有一点是，Qt 要求QObject的所有子对象都必须和其父对象在同一线程。这意味着：<br>　　　不能对有父对象（parent 属性）的对象使用QObject::moveToThread()函数；<br>　　　不能在QThread中以这个QThread本身作为父对象创建对象，这是因为QThread对象所依附的线程是创建它的那个线程，而不是它所代表的线程。<br>　  Qt 还要求，在代表一个线程的QThread对象销毁之前，所有在这个线程中的对象都必须先delete。要达到这一点并不困难：我们只需在QThread::run()的栈上创建对象即可。<br>　  现在的问题是，既然线程创建的对象都只能在函数栈上，怎么能让这些对象与其它线程的对象通信呢？Qt 提供了一个优雅清晰的解决方案：我们在线程的事件队列中加入一个事件，然后在事件处理函数中调用我们所关心的函数。显然这需要线程有一个事件循环。这种机制依赖于 moc 提供的反射：因此，只有信号、槽和使用Q_INVOKABLE宏标记的函数可以在另外的线程中调用。</p></blockquote></li><li><p><a href="http://www.devbean.net/2013/12/qt-study-road-2-thread-summary/" target="_blank" rel="noopener">Qt 学习之路 2（75）：线程总结</a></p><blockquote><p>　  有关线程，你可以做的是：<br>　　  在QThread子类添加信号。这是绝对安全的，并且也是正确的（前面我们已经详细介绍过，发送者的线程依附性没有关系）<br>　  不应该做的是：<br>　　  调用moveToThread(this)函数<br>　 　 指定连接类型：这通常意味着你正在做错误的事情，比如将QThread控制接口与业务逻辑混杂在了一起（而这应该放在该线程的一个独立对象中）<br>　  　 在QThread子类添加槽函数：这意味着它们将在错误的线程被调用，也就是QThread对象所在线程，而不是QThread对象管理的线程。这又需要你指定连接类型或者调用moveToThread(this)函数<br>　 　 使用QThread::terminate()函数<br>　  不能做的是：<br>　　  在线程还在运行时退出程序。使用QThread::wait()函数等待线程结束<br>　 　 在QThread对象所管理的线程仍在运行时就销毁该对象。如果你需要某种“自行销毁”的操作，你可以把finished()信号同deleteLater()槽连接起来<br>　　—————————————————————————<br>　  那么，下面一个问题是：我什么时候应该使用线程？<br>　　　首先，当你不得不使用同步 API 的时候。<br>　　　其次，当你希望扩展到多核应用的时候。<br>　　　第三，当你不想被别人阻塞的时候。<br>　　—————————————————————————<br>　　那么，什么情况下不应该使用线程呢？<br>　　　定时器<br>　　　网络/状态机<br>　　　将任务分割成若干部分</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（九）—《QT学习之路2》摘录-7（访问网络）</title>
      <link href="/2014/11/23/learn-qt-nine/"/>
      <url>/2014/11/23/learn-qt-nine/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2013/10/qt-study-road-2-access-network-1/" target="_blank" rel="noopener">Qt 学习之路 2（65）：访问网络（1）</a><blockquote><p>　　Qt 进行网络访问的类是QNetworkAccessManager，这是一个名字相当长的类，不过使用起来并不像它的名字一样复杂。<strong>为了使用网络相关的类，你需要在 pro 文件中添加QT += network</strong>。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　QNetworkAccessManager类允许应用程序发送网络请求以及接受服务器的响应。事实上，Qt 的整个访问网络 API 都是围绕着这个类进行的。QNetworkAccessManager保存发送的请求的最基本的配置信息，包含了代理和缓存的设置。<strong>最好的是，这个 API 本身就是异步设计，这意味着我们不需要自己为其开启线程，以防止界面被锁死</strong>（这里我们可以简单了解下，Qt 的界面活动是在一个主线程中进行。网络访问是一个相当耗时的操作，如果整个网络访问的过程以同步的形式在主线程进行，则当网络访问没有返回时，主线程会被阻塞，界面就会被锁死，不能执行任何响应，甚至包括一个代表响应进度的滚动条都会被卡死在那里。这种设计显然是不友好的。）。异步的设计避免了这一系列的问题，但是却要求我们使用更多的代码来监听返回。这类似于我们前面提到的QDialog::exec()和QDialog::show()之间的区别。<strong>QNetworkAccessManager是使用信号槽来达到这一目的的</strong>。<br>　　<strong>一个应用程序仅需要一个QNetworkAccessManager类的实例。所以，虽然QNetworkAccessManager本身没有被设计为单例，但是我们应该把它当做单例使用。</strong>一旦一个QNetworkAccessManager实例创建完毕，我们就可以使用它发送网络请求。这些请求都返回QNetworkReply对象作为响应。这个对象一般会包含有服务器响应的数据。<br>　　————————————————————————-<br>　　我们的程序是一个简单的天气预报的程序，使用 OpenWeatherMap 的 API 获取数据。我们可以在<a href="http://www.openweathermap.org/api" target="_blank" rel="noopener">这里</a>找到其 API 的具体介绍。<br>　　————————————————————————-</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// !!! Qt5</span><br><span class="line">#ifndef NETWORKER_H</span><br><span class="line">#define NETWORKER_H</span><br><span class="line"></span><br><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">class QNetworkReply;</span><br><span class="line"></span><br><span class="line">class NetWorker : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    static NetWorker * instance();</span><br><span class="line">    ~NetWorker();</span><br><span class="line"></span><br><span class="line">    void get(const QString &amp;url);</span><br><span class="line">signals:</span><br><span class="line">    void finished(QNetworkReply *reply);</span><br><span class="line">private:</span><br><span class="line">    class Private;</span><br><span class="line">    friend class Private;</span><br><span class="line">    Private *d;</span><br><span class="line"></span><br><span class="line">    explicit NetWorker(QObject *parent = 0);</span><br><span class="line">    NetWorker(const NetWorker &amp;) Q_DECL_EQ_DELETE;</span><br><span class="line">    NetWorker&amp; operator=(NetWorker rhs) Q_DECL_EQ_DELETE;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // NETWORKER_H</span><br></pre></td></tr></table></figure><blockquote><p>　　NetWorker是一个单例类，因此它有一个instance()函数用来获得这唯一的实例。<strong>作为单例模式，要求构造函数、拷贝构造函数和赋值运算符都是私有的，因此我们将这三个函数都放在 private 块中。注意我们增加了一个Q_DECL_EQ_DELETE宏。这个宏是 Qt5 新增加的，意思是将它所修饰的函数声明为 deleted（这是 C++11 的新特性）。如果编译器支持= delete语法，则这个宏将会展开为= delete，否则则展开为空。</strong>我们的NetWorker只有一个get函数，顾名思义，这个函数会执行 HTTP GET 操作；一个信号finished()，会在获取到服务器响应后发出。private 块中还有三行关于Private的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Private;</span><br><span class="line">friend class Private;</span><br><span class="line">Private *d;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>　　这里声明了一个NetWorker的内部类，然后声明了这个内部类的 d 指针。<strong>d 指针是 C++ 程序常用的一种设计模式。它的存在于 C++ 程序的编译有关。</strong>在 C++ 中，保持二进制兼容性非常重要。如果你能够保持二进制兼容，则当以后升级库代码时，用户不需要重新编译自己的程序即可直接运行（如果你使用 Qt5.0 编译了一个程序，这个程序不需要重新编译就可以运行在 Qt5.1 下，这就是二进制兼容；如果不需要修改源代码，但是必须重新编译才能运行，则是源代码兼容；如果必须修改源代码并且再经过编译，例如从 Qt4 升级到 Qt5，则称二者是不兼容的）。保持二进制兼容的很重要的一个原则是不要随意增加、删除成员变量。因为这会导致类成员的寻址偏移量错误，从而破坏二进制兼容。为了避免这个问题，我们将一个类的所有私有变量全部放进一个单独的辅助类中，而在需要使用这些数据的类值提供一个这个辅助类的指针。<strong>注意，由于我们的辅助类是私有的，用户不能使用它，所以针对这个辅助类的修改不会影响到外部类，从而保证了二进制兼容。</strong>关于二进制兼容的问题，我们会在以后的文章中更详细的说明，这里仅作此简单介绍。<br>　　下面来看NetWorker的实现：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class NetWorker::Private</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Private(NetWorker *q) :</span><br><span class="line">        manager(new QNetworkAccessManager(q))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    QNetworkAccessManager *manager;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>　　Private是NetWorker的内部类，扮演者前面我们所说的那个辅助类的角色。NetWorker::Private类主要有一个成员变量QNetworkAccessManager *，把QNetworkAccessManager封装起来。NetWorker::Private需要其被辅助的类NetWorker的指针，目的是作为QNetworkAccessManager的 parent，以便NetWorker析构时能够自动将QNetworkAccessManager析构。当然，我们也可以通过将NetWorker::Private声明为QObject的子类来达到这一目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NetWorker *NetWorker::instance()</span><br><span class="line">&#123;</span><br><span class="line">    static NetWorker netWorker;</span><br><span class="line">    return &amp;netWorker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>　　instance()函数很简单，我们声明了一个 static 变量，将其指针返回。<strong>这是 C++ 单例模式的最简单写法，由于 C++ 标准要求类的构造函数不能被打断，因此这样做也是线程安全的。</strong></p></blockquote><ul><li><p><a href="http://www.devbean.net/2013/10/qt-study-road-2-access-network-2/" target="_blank" rel="noopener">Qt 学习之路 2（66）：访问网络（2）</a></p></li><li><p><a href="http://www.devbean.net/2013/11/qt-study-road-2-access-network-3/" target="_blank" rel="noopener">Qt 学习之路 2（67）：访问网络（3）</a></p></li><li><p><a href="http://www.devbean.net/2013/11/qt-study-road-2-access-network-4/" target="_blank" rel="noopener">Qt 学习之路 2（68）：访问网络（4）</a></p><blockquote><p>　　如果你仔细观察就会发现，即便我们没有添加任何相关代码，QNetworkAccessManager的网络访问并不会阻塞 GUI 界面。也就是说，即便是在进行网络访问的时候，我们的界面还是可以响应的。<strong>相比之下，如果你对 Java 熟悉，就会了解到，在 Java 中，进行 Socket 通讯时，界面默认是阻塞的，当程序进行网络访问操作时，界面不能对我们的操作做出任何响应。由此可以看出，QNetworkAccessManager的网络访问默认就是异步的、非阻塞的。</strong>这样的实现固然很好，也符合大多数程序的应用情形：我们当然希望程序界面能够始终对用户操作做出响应。不过，在某些情况下，我们还是希望会有一些同步的网络操作。典型的是登录操作。在登录时，我们必须要等待网络返回结果，才能让界面做出响应：是验证成功进入系统，还是验证失败做出提示？这就是本章的主要内容：如何使用QNetworkAccessManager进行同步网络访问。<br>　　————————————————————————-<br>　　要解决这种情况，我们可以在有网络请求时将界面锁死，不允许用户进行更多的操作（更好的方法是仅仅锁住某些按钮，而不是整个界面。不过这里我们以锁住整个界面为例）。我们的解决方案很简单：当QNetworkAccessManager发出请求之后，我们进入一个新的事件循环，将操作进行阻塞。我们的代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void fetchWeather(const QString &amp;cityName)</span><br><span class="line">&#123;</span><br><span class="line">    QEventLoop eventLoop;</span><br><span class="line">    connect(netWorker, &amp;NetWorker::finished,</span><br><span class="line">            &amp;eventLoop, &amp;QEventLoop::quit);</span><br><span class="line">    QNetworkReply *reply = netWorker-&gt;get(QString(&quot;http://api.openweathermap.org/data/2.5/weather?q=%1&amp;mode=json&amp;units=metric&amp;lang=zh_cn&quot;).arg(cityName));</span><br><span class="line">    replyMap.insert(reply, FetchWeatherInfo);</span><br><span class="line">    eventLoop.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>　　注意，我们在函数中创建了一个QEventLoop实例，将其quit()与NetWorker::finished()信号连接起来。当NetWorker::finished()信号发出时，QEventLoop::quit()就会被调用。在NetWorker::get()执行之后，调用QEventLoop::exec()函数开始事件循环。此时界面就是被阻塞。<br>　　现在我们只是提供了一种很简单的思路。当然这并不是最好的思路：程序界面直接被阻塞，用户获得不了任何提示，会误以为程序死掉。更好的做法是做一个恰当的提示，不过这已经超出我们本章的范畴。更重要的是，这种思路并不完美。<strong>如果你的程序是控制台程序（没有 GUI 界面），或者是某些特殊的情况下，会造出死锁！控制台程序中发送死锁的原因在于在非 GUI 程序中另外启动事件循环会将主线程阻塞，QNetworkAccessManager的所有信号都不会收到。“某些特殊的情况”，我们会在后面有关线程的章节详细解释。不过，要完美解决这个问题，我们必须使用另外的线程。</strong><a href="http://www.codeproject.com/Articles/484905/Use-QNetworkAccessManager-for-synchronous-download" target="_blank" rel="noopener">这里</a>有一个通用的解决方案，感兴趣的童鞋可以详细了解下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（八）—《QT学习之路2》摘录-6（容器）</title>
      <link href="/2014/11/23/learn-qt-eight/"/>
      <url>/2014/11/23/learn-qt-eight/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2013/01/qt-study-road-2-containers/" target="_blank" rel="noopener">Qt 学习之路 2（38）：存储容器</a><blockquote><p>　　存储容器（containers）有时候也被称为集合（collections），是能够在内存中存储其它特定类型的对象，通常是一些常用的数据结构，一般是通用模板类的形式。C++ 提供了一套完整的解决方案，作为标准模板库（Standard Template Library）的组成部分，也就是常说的 STL。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　Qt 提供了另外一套基于模板的容器类。相比 STL，这些容器类通常更轻量、更安全、更容易使用。如果你对 STL 不大熟悉，或者更喜欢 Qt 风格的 API，那么你就应该选择使用这些类。当然，你也可以在 Qt 中使用 STL 容器，没有任何问题。<br>　　本章的目的，是让你能够选择使用哪个容器，而不是告诉你这个类都哪些函数。这个问题可以在文档中找到更清晰的回答。<br>　　<strong>Qt 的容器类都不继承QObject，都提供了隐式数据共享、不可变的特性，并且为速度做了优化，具有较低的内存占用量等。另外一点比较重要的，它们是线程安全的。</strong>这些容器类是平台无关的，即不因编译器的不同而具有不同的实现；隐式数据共享，有时也被称作“写时复制（copy on write）”，这种技术允许在容器类中使用传值参数，但却不会出现额外的性能损失。遍历是容器类的重要操作。<strong>Qt 容器类提供了类似 Java 的遍历器语法，同样也提供了类似 STL 的遍历器语法，以方便用户选择自己习惯的编码方式。相比而言，Java 风格的遍历器更易用，是一种高层次的函数；而 STL 风格的遍历器更高效，同时能够支持 Qt 和 STL 的通用算法。最后一点，在一些嵌入式平台，STL 往往是不可用的，这时你就只能使用 Qt 提供的容器类，除非你想自己创建。</strong>顺便提一句，除了遍历器，Qt 还提供了自己的 foreach 语法（C++ 11 也提供了类似的语法，但有所区别，详见<a href="http://www.devbean.net/2012/06/cpp11-in-qt4/" target="_blank" rel="noopener">这里</a>的 foreach 循环一节）。<br>　　Qt 提供了顺序存储容器：QList，QLinkedList，QVector，QStack和QQueue。对于绝大多数应用程序，QList是最好的选择。虽然它是基于数组实现的列表，但它提供了快速的向前添加和向后追加的操作。如果你需要链表，可以使用QLinkedList。如果你希望所有元素占用连续地址空间，可以选择QVector。QStack和QQueue则是 LIFO 和 FIFO 的。<br>　　Qt 还提供了关联容器：QMap，QMultiMap，QHash，QMultiHash和QSet。带有“Multi”字样的容器支持在一个键上面关联多个值。“Hash”容器提供了基于散列函数的更快的查找，而非 Hash 容器则是基于二分搜索的有序集合。<br>　　另外两个特例：QCache和QContiguousCache提供了在有限缓存空间中的高效 hash 查找。<br>　　我们将 Qt 提供的各个容器类总结如下：<br>　　QList<t>：这是至今为止提供的最通用的容器类。它将给定的类型 T 的对象以列表的形式进行存储，与一个整型的索引关联。QList在内部使用数组实现，同时提供基于索引的快速访问。我们可以使用 QList::append()和QList::prepend()在列表尾部或头部添加元素，也可以使用QList::insert()在中间插入。相比其它容器类，QList专门为这种修改操作作了优化。QStringList继承自QList<qstring>。<br>　　QLinkedList<t>：类似于 QList，除了它是使用遍历器进行遍历，而不是基于整数索引的随机访问。对于在中部插入大量数据，它的性能要优于QList。同时具有更好的遍历器语义（只要数据元素存在，QLinkedList的遍历器就会指向一个合法元素，相比而言，当插入或删除数据时，QList的遍历器就会指向一个非法值）。<br>　　QVector<t>：用于在内存的连续区存储一系列给定类型的值。在头部或中间插入数据可能会非常慢，因为这会引起大量数据在内存中的移动。<br>　　QStack<t>：这是QVector的子类，提供了后进先出（LIFO）语义。相比QVector，它提供了额外的函数：push()，pop()和top()。<br>　　QQueue<t>：这是QList的子类，提供了先进先出（FIFO）语义。相比QList，它提供了额外的函数：enqueue()，dequeue()和head()。<br>　　QSet<t>：提供单值的数学上面的集合，具有快速的查找性能。<br>　　QMap&lt;Key, T&gt;：提供了字典数据结构（关联数组），将类型 T 的值同类型 Key 的键关联起来。通常，每个键与一个值关联。QMap以键的顺序存储数据；如果顺序无关，QHash提供了更好的性能。<br>　　QMultiMap&lt;Key, T&gt;：这是QMap的子类，提供了多值映射：一个键可以与多个值关联。<br>　　QHash&lt;Key, T&gt;：该类同QMap的接口几乎相同，但是提供了更快的查找。QHash以字母顺序存储数据。<br>　　QMultiHash&lt;Key, T&gt;：这是QHash的子类，提供了多值散列。<br>　　所有的容器都可以嵌套。例如，QMap&lt;QString, QList<int> &gt;是一个映射，其键是QString类型，值是QList<int>类型，也就是说，每个值都可以存储多个 int。这里需要注意的是，C++ 编译器会将连续的两个 &gt; 当做输入重定向运算符，因此，这里的两个 &gt; 中间必须有一个空格。<br>　　<strong>能够存储在容器中的数据必须是可赋值数据类型。所谓可赋值数据类型，是指具有默认构造函数、拷贝构造函数和赋值运算符的类型。</strong>绝大多数数据类型，包括基本类型，比如 int 和 double，指针，Qt 数据类型，例如QString、QDate和QTime，都是可赋值数据类型。<strong>但是，QObject及其子类（QWidget、QTimer等）都不是。也就是说，你不能使用QList<qwidget>这种容器，因为QWidget的拷贝构造函数和赋值运算符不可用。如果你需要这种类型的容器，只能存储其指针，也就是QList<qwidget *>。</qwidget></qwidget></strong><br>　　<strong>如果要使用QMap或者QHash，作为键的类型必须提供额外的辅助函数。QMap的键必须提供operator&lt;()重载，QHash的键必须提供operator==()重载和一个名字是qHash()的全局函数。</strong></int></int></t></t></t></t></t></qstring></t></p></blockquote><ul><li><a href="http://www.devbean.net/2013/01/qt-study-road-2-iterator/" target="_blank" rel="noopener">Qt 学习之路 2（39）：遍历容器</a><blockquote><p>　　Qt 的容器类提供了两种风格的遍历器：Java 风格和 STL 风格。这两种风格的遍历器在通过非 const 函数对集合进行修改时都是不可用的。<br>　　<strong>Java 风格的遍历器</strong><br>　　Java 风格的遍历器是在 Qt4 首先引入的，是 Qt 应用程序首先推荐使用的形式。这种风格比起 STL 风格的遍历器更方便。方便的代价就是不如后者高效。它们的 API 非常类似于 Java 的遍历器类，故名。<br>　　每一种容器都有两种 Java 风格的遍历器：一种提供只读访问，一种提供读写访问：</p></blockquote></li></ul><table><thead><tr><th>容器    只读遍历器</th><th>读写遍历器</th></tr></thead><tbody><tr><td>QList<t>,QQueue<t></t></t></td><td>QListIterator<t>    QMutableListIterator<t></t></t></td></tr><tr><td>QLinkedList<t></t></td><td>QLinkedListIterator<t>    QMutableLinkedListIterator<t></t></t></td></tr><tr><td>QVector<t>,QStack<t></t></t></td><td>QVectorIterator<t>    QMutableVectorIterator<t></t></t></td></tr><tr><td>QSet<t>    QSetIterator<t></t></t></td><td>QMutableSetIterator<t></t></td></tr><tr><td>QMap&lt;Key, T&gt;,QMultiMap&lt;Key, T&gt;</td><td>QMapIterator<t>    QMutableMapIterator<t></t></t></td></tr><tr><td>QHash&lt;Key, T&gt;,QMultiHash&lt;Key, T&gt;</td><td>QHashIterator<t>    QMutableHashIterator<t></t></t></td></tr></tbody></table><blockquote><p>　　不同于下面我们将要介绍的 STL 风格的遍历器，Java 风格的遍历器指向的是两个元素之间的位置，而不是指向元素本身。因此，它们可能会指向集合第一个元素之前的位置，也可能指向集合的最后一个元素之后的位置。<br>　　我们通过调用hasNext()函数判断遍历器之后的位置上有无元素。如果有，调用next()函数将遍历器跳过其后的元素。next()函数返回刚刚跳过的元素。当然，我们也可以使用hasPrevious()和previous()函数来从尾部开始遍历，详细内容可以参考 API 文档。<br>　　QListIterator是只读遍历器，不能插入或者删除数据。如果需要这些操作，我们可以使用QMutableListIterator。<br>　　<strong>STL 风格的遍历器</strong><br>　　STL 风格的遍历器从 Qt 2.0 就开始提供。这种遍历器能够兼容 Qt 和 STL 的通用算法，并且为速度进行了优化。同 Java 风格遍历器类似，Qt 也提供了两种 STL 风格的遍历器：一种是只读访问，一种是读写访问。我们推荐尽可能使用只读访问，因为它们要比读写访问的遍历器快一些。</p></blockquote><table><thead><tr><th>容器</th><th>只读遍历器</th><th>读写遍历器</th></tr></thead><tbody><tr><td>QList<t>,QQueue<t></t></t></td><td>QList<t>::const_iterator</t></td><td>QList<t>::iterator</t></td></tr><tr><td>QLinkedList<t></t></td><td>QLinkedList<t>::const_iterator</t></td><td>QLinkedList<t>::iterator</t></td></tr><tr><td>QVector<t>,QStack<t></t></t></td><td>QVector<t>::const_iterator</t></td><td>QVector<t>::iterator</t></td></tr><tr><td>QSet<t></t></td><td>QSet<t>::const_iterator</t></td><td>QSet<t>::iterator</t></td></tr><tr><td>QMap&lt;Key, T&gt;,QMultiMap&lt;Key, T&gt;</td><td>QMap&lt;Key, T&gt;::const_iterator</td><td>QMap&lt;Key, T&gt;::iterator</td></tr><tr><td>QHash&lt;Key, T&gt;,QMultiHash&lt;Key, T&gt;</td><td>QHash&lt;Key, T&gt;::const_iterator</td><td>QHash&lt;Key, T&gt;::iterator</td></tr></tbody></table><blockquote><p>　　STL 风格的遍历器具有类似数组指针的行为。例如，我们可以使用 ++ 运算符让遍历器移动到下一个元素，使用 <em> 运算符获取遍历器所指的元素。对于QVector和QStack，虽然它们是在连续内存区存储元素，遍历器类型是`typedef T </em><code>，const_iterator类型则是</code>typedef const T *`。<br>　　不同于 Java 风格遍历器，STL 风格遍历器直接指向元素本身。容器的begin()函数返回指向该容器第一个元素的遍历器；end()函数返回指向该容器最后一个元素之后的元素的遍历器。end()实际是一个非法位置，永远不可达。这是为跳出循环做的一个虚元素。如果集合是空的，begin()等于end()，我们就不能执行循环。<br>　　由于有隐式数据共享（我们会在后面的章节介绍该部分内容），即使一个函数返回集合中元素的值也不会有很大的代价。Qt API 包含了很多以值的形式返回QList或QStringList的函数（例如QSplitter::sizes()）。如果你希望使用 STL 风格的遍历器遍历这样的元素，应该使用容器的拷贝，例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 正确的方式</span><br><span class="line">const QList&lt;QString&gt; sizes = splitter-&gt;sizes();</span><br><span class="line">QList&lt;QString&gt;::const_iterator i;</span><br><span class="line">for (i = sizes.begin(); i != sizes.end(); ++i)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">// 错误的方式</span><br><span class="line">QList&lt;QString&gt;::const_iterator i;</span><br><span class="line">for (i = splitter-&gt;sizes().begin();</span><br><span class="line">     i != splitter-&gt;sizes().end(); ++i)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>　　<strong>这个问题不存在于那些返回集合的 const 或非 const 引用的函数。隐式数据共享对 STL 风格遍历器造成的另外影响是，在容器上运行着非 const 遍历器的时候，不能对容器进行拷贝。Java 风格的遍历器没有这个问题。</strong><br>　　<strong>foreach关键字</strong><br>　　如果类型名中带有逗号，比如QPair&lt;int, int&gt;，我们只能像上面一样，先创建一个对象，然后使用foreach关键字。如果没有逗号，则可以直接在foreach关键字中使用新的对象。<br>　　<strong>Qt 会在foreach循环时自动拷贝容器。这意味着，如果在遍历时修改集合，对于正在进行的遍历是没有影响的。即使不修改容器，拷贝也是会发生的。但是由于存在隐式数据共享，这种拷贝还是非常迅速的。</strong><br>　　<strong>因为foreach创建了集合的拷贝，使用集合的非 const 引用也不能实际修改原始集合，所修改的只是这个拷贝。</strong></p></blockquote><ul><li><a href="http://www.devbean.net/2013/01/qt-study-road-2-implicit-sharing/" target="_blank" rel="noopener">Qt 学习之路 2（40）：隐式数据共享</a><blockquote><p>　　Qt 中许多 C++ 类使用了隐式数据共享技术，来最大化资源利用率和最小化拷贝时的资源消耗。当作为参数传递时，具有隐式数据共享的类即安全又高效。在数据传递时，实际上只是传递了数据的指针（这一切都是隐含帮你完成的），而只有在函数发生需要写入的情况时，数据才会被拷贝（也就是通常所说的写时复制）。本章我们将介绍有关隐式数据共享的相关内容，以便为恰当地使用前面所介绍的容器夯实基础。<br>　　具有数据共享能力的类包含了一个指向共享数据块的指针。这个数据块包含了数据本身以及数据的引用计数。当共享对象创建出来时，引用计数被设置为 1。当新的对象引用到共享数据时，引用计数增加；当对象引用不再引用数据时，引用计数减少。当引用计数变为 0 时，共享数据被删除。<br>　　在我们操作共享数据时，实际有两种拷贝对象的方法：我们通常称其为深拷贝和浅拷贝。深拷贝意味着要重新构造一个全新的对象；浅拷贝则仅仅复制引用，也就是上面所说的那个指向共享数据块的指针。深拷贝对内存和 CPU 资源都是很昂贵的；浅拷贝则非常快速，因为它仅仅是设置一个新的指针，然后将引用计数加 1。具有隐式数据共享的对象，其赋值运算符使用的是浅拷贝来实现的。<br>　　这种隐式数据共享的好处是，程序不需要拥有不必要的重复数据，减少数据拷贝的需求。重复数据的代价是降低内存使用率（因为内存存储了更多重复的数据）。通过数据共享，对象可以更简单地作为值来传递以及从函数中返回。<br>　　隐式数据共享是在底层自动完成的，程序人员无需关心。这也是“隐式”一词的含义。从 Qt4 开始，即使在多线程程序中，隐式数据共享也是起作用的。在很多人看来，隐式数据共享和多线程是不兼容的，这是由引用计数的实现方式决定的。但是，Qt 使用了原子性的引用计数来避免多线程环境下可能出现的执行顺序打断的行为。需要注意的是，原子引用计数并不能保证线程安全，还是需要恰当的锁机制。这种观点对所有类似的场合都是适用的。原子引用计数能够保证的是，线程肯定操作自己的数据，线程自己的数据是安全的。总的来说，从 Qt4 开始，你可以放心使用隐式数据共享的类，即使在多线程环境下。<br>　　我们可以使用QSharedData和QSharedDataPointer类实现自己的隐式数据共享类。<br>　　当对象即将被修改，并且其引用计数大于 1 时，隐式数据共享自动将数据从共享块中拿出。隐式共享类必须控制其内部数据，在任何修改其数据的函数中，将数据自动取出。<br>　　————————————————————————-<br>　　凡是支持隐式数据共享的 Qt 类都支持类似的操作。用户甚至不需要知道对象其实已经共享。因此，你应该把这样的类当作普通类一样，而不应该依赖于其共享的特色作一些“小动作”。事实上，这些类的行为同普通类一样，只不过添加了可能的共享数据的优点。因此，你大可以使用按值传参，而无须担心数据拷贝带来的性能问题。<br>　　————————————————————————-<br>　　<strong>注意，前面已经提到过，不要在使用了隐式数据共享的容器上，在有非 const STL 风格的遍历器正在遍历时复制容器。另外还有一点，对于QList或者QVector，我们应该使用at()函数而不是 [] 操作符进行只读访问。原因是 [] 操作符既可以是左值又可以是右值，这让 Qt 容器很难判断到底是左值还是右值，这意味着无法进行隐式数据共享；而at()函数不能作左值，因此可以进行隐式数据共享。另外一点是，对于begin()，end()以及其他一些非 const 遍历器，由于数据可能改变，因此 Qt 会进行深复制。为了避免这一点，要尽可能使用const_iterator、constBegin()和constEnd()。</strong></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（七）—《QT学习之路2》摘录-5（文件）</title>
      <link href="/2014/11/22/learn-qt-seven/"/>
      <url>/2014/11/22/learn-qt-seven/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2013/01/qt-study-road-2-file/" target="_blank" rel="noopener">Qt 学习之路 2（35）：文件</a><blockquote><p>　　文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。从本章开始，我们来了解下 Qt 的文件以及输入输出的功能，也就是 I/O 系统。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　Qt 通过QIODevice提供了对 I/O 设备的抽象，这些设备具有读写字节块的能力。下面是 I/O 设备的类图：<br>　　<img src="http://keke-hexo-blog.qiniudn.com/image/QT/qt5-io-device2.png" alt><br>　　Qt5 新增加了一个QFileDevice类。途中所涉及的类及其用途简要说明如下：<br>　　　QIODevice：所有 I/O 设备类的父类，提供了字节块读写的通用操作以及基本接口；<br>　　　QFlie：访问本地文件或者嵌入资源；<br>　　　QTemporaryFile：创建和访问本地文件系统的临时文件；<br>　　　QBuffer：读写QByteArray；<br>　　　QProcess：运行外部程序，处理进程间通讯；<br>　　　QAbstractSocket：所有套接字类的父类；<br>　　　QTcpSocket：TCP协议网络数据传输；<br>　　　QUdpSocket：传输 UDP 报文；<br>　　　QSslSocket：使用 SSL/TLS 传输数据；<br>　　　QFileDevice：Qt5新增加的类，提供了有关文件操作的通用实现。<br>　　这其中，QProcess、QTcpSocket、QUdpSoctet和QSslSocket是顺序访问设备。所谓“顺序访问”，是指它们的数据只能访问一遍：从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回去读取上一个字节；QFile、QTemporaryFile和QBuffer是随机访问设备，可以访问任意位置任意次数，还可以使用QIODevice::seek()函数来重新定位文件访问位置指针。<br>　　———————————————————————–<br>　　我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改。QFile需要使用 / 作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如 C:/windows 这样的路径在 Windows 平台下同样是可以的。<br>　　QFile主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取，而不是自己分析文件路径字符串。<br>　　———————————————————————–<br>　　程序的第二部分，我们使用QFileInfo获取有关该文件的信息。QFileInfo有很多类型的函数，我们只举出一些例子。比如这里，isDir()检查该文件是否是目录；isExecutable()检查该文件是否是可执行文件等。baseName()可以直接获得文件名；suffix()则直接获取文件后缀名。我们可以由下面的示例看到，baseName()和completeBaseName()，以及suffix()和completeSuffix()的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QFileInfo fi(&quot;/tmp/archive.tar.gz&quot;);</span><br><span class="line">QString base  = fi.baseName();  // base = &quot;archive&quot;</span><br><span class="line">QString cbase = fi.completeBaseName();  // base = &quot;archive.tar&quot;</span><br><span class="line">QString ext   = fi.suffix();  // ext = &quot;gz&quot;</span><br><span class="line">QString ext   = fi.completeSuffix();  // ext = &quot;tar.gz&quot;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li><a href="http://www.devbean.net/2013/01/qt-study-road-2-binary-file-io/" target="_blank" rel="noopener">Qt 学习之路 2（36）：二进制文件读写</a><blockquote><p>　　QDataStream提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以直接读写没有编码的二进制数据，例如图像、视频、音频等。<br>　　QDataStream既能够存取 C++ 基本类型，如 int、char、short 等，也可以存取复杂的数据类型，例如自定义的类。实际上，QDataStream对于类的存储，是将复杂的类分割为很多基本单元实现的。<br>　　结合QIODevice，QDataStream可以很方便地对文件、网络套接字等进行读写操作。<br>　　———————————————————————–<br>　　但是，如果你直接运行这段代码，你会得到一个空白的 file.dat，并没有写入任何数据。这是因为我们的file没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：<br>　　<code>file.close(); // 如果不想关闭文件，可以使用 file.flush();</code><br>　　唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。也就是说，程序数据写入的顺序必须预先定义好。在这个例子中，我们首先写入字符串，然后写入数字，那么就首先读出来的就是字符串，然后才是数字。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。<br>　　由于二进制流是纯粹的字节数据，带来的问题是，如果程序不同版本之间按照不同的方式读取（前面说过，Qt 保证读写内容的一致，但是并不能保证不同 Qt 版本之间的一致），数据就会出现错误。因此，我们必须提供一种机制来确保不同版本之间的一致性。通常，我们会使用如下的代码写入：</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QFile file(&quot;file.dat&quot;);</span><br><span class="line">file.open(QIODevice::WriteOnly);</span><br><span class="line">QDataStream out(&amp;file);</span><br><span class="line"></span><br><span class="line">// 写入魔术数字和版本</span><br><span class="line">out &lt;&lt; (quint32)0xA0B0C0D0;</span><br><span class="line">out &lt;&lt; (qint32)123;</span><br><span class="line"></span><br><span class="line">out.setVersion(QDataStream::Qt_4_0);</span><br><span class="line"></span><br><span class="line">// 写入数据</span><br><span class="line">out &lt;&lt; lots_of_interesting_data;</span><br></pre></td></tr></table></figure><blockquote><p>　　这里，我们增加了两行代码：<br>　　<code>out &lt;&lt; (quint32)0xA0B0C0D0;</code><br>　　用于写入魔术数字。所谓魔术数字，是二进制输出中经常使用的一种技术。二进制格式是人不可读的，并且通常具有相同的后缀名（比如 dat 之类），因此我们没有办法区分两个二进制文件哪个是合法的。所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性。在本例中，我们在文件最开始写入 0xA0B0C0D0，在读取的时候首先检查这个数字是不是 0xA0B0C0D0。如果不是的话，说明这个文件不是可识别格式，因此根本不需要去继续读取。一般二进制文件都会有这么一个魔术数字，例如 Java 的 class 文件的魔术数字就是 0xCAFEBABE，使用二进制查看器就可以查看。魔术数字是一个 32 位的无符号整型，因此我们使用quint32来得到一个平台无关的 32 位无符号整型。<br>　　接下来一行，<br>　　<code>out &lt;&lt; (qint32)123;</code><br>　　是标识文件的版本。我们用魔术数字标识文件的类型，从而判断文件是不是合法的。但是，文件的不同版本之间也可能存在差异：我们可能在第一版保存整型，第二版可能保存字符串。为了标识不同的版本，我们只能将版本写入文件。比如，现在我们的版本是 123。<br>　　———————————————————————–<br>　　QDataStream同QIODevice有什么区别？区别在于，QDataStream提供流的形式，性能上一般比直接调用原始 API 更好一些。<br>　　———————————————————————–<br>　　在这段代码中，我们首先向文件中写入数据，紧接着把数据读出来。有什么问题吗？运行之后你会发现，strout实际是空的。为什么没有读取出来？我们不是已经添加了file.flush();语句吗？原因并不在于文件有没有写入，而是在于我们使用的是“流”。所谓流，就像水流一样，它的游标会随着输出向后移动。当使用&lt;&lt;操作符输出之后，流的游标已经到了最后，此时你再去读，当然什么也读不到了。所以你需要在输出之后重新把游标设置为 0 的位置才能够继续读取。具体代码片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream &lt;&lt; str;</span><br><span class="line">stream.device()-&gt;seek(0);</span><br><span class="line">stream &gt;&gt; strout;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li><a href="http://www.devbean.net/2013/01/qt-study-road-2-text-file-io/" target="_blank" rel="noopener">Qt 学习之路 2（37）：文本文件读写</a><blockquote><p>　　而文本文件是一种人可读的文件。为了操作这种文件，我们需要使用QTextStream类。QTextStream和QDataStream的使用类似，只不过它是操作纯文本文件的。另外，像 XML、HTML 这种，虽然也是文本文件，可以由QTextStream生成，但 Qt 提供了更方便的 XML 操作类，这里就不包括这部分内容了。<br>　　QTextStream会自动将 Unicode 编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。QTextStream使用 16 位的QChar作为基础的数据存储单位，同样，它也支持 C++ 标准类型，如 int 等。实际上，这是将这种标准类型与字符串进行了相互转换。<br>　　———————————————————————–<br>　　我们可以从下表中看到这些打开方式的区别：</p></blockquote></li></ul><table><thead><tr><th>枚举值</th><th>描述</th></tr></thead><tbody><tr><td>QIODevice::NotOpen</td><td>未打开</td></tr><tr><td>QIODevice::ReadOnly</td><td>以只读方式打开</td></tr><tr><td>QIODevice::WriteOnly</td><td>以只写方式打开</td></tr><tr><td>QIODevice::ReadWrite</td><td>以读写方式打开</td></tr><tr><td>QIODevice::Append</td><td>以追加的方式打开，新增加的内容将被追加到文件末尾</td></tr><tr><td>QIODevice::Truncate</td><td>以重写的方式打开，在写入新的数据时会将原有数据全部清除，游标设置在文件开头。</td></tr><tr><td>QIODevice::Text</td><td>在读取时，将行结束符转换成 \n；在写入时，将行结束符转换成本地格式，例如 Win32 平台上是 \r\n</td></tr><tr><td>QIODevice::Unbuffered</td><td>忽略缓存</td></tr></tbody></table><blockquote><p>　 　我们在这里使用了QFile::WriteOnly | QIODevice::Truncate，也就是以只写并且覆盖已有内容的形式操作文件。注意，QIODevice::Truncate会直接将文件内容清空。<br>　 　———————————————————————–<br>　 　这是因为以文本形式写入数据，是没有数据之间的分隔的。还记得我们前面曾经说过，使用QDataStream写入的时候，实际上会在要写入的内容前面，额外添加一个这段内容的长度值。而文本文件则没有类似的操作。因此，使用文本文件时，很少会将其分割开来读取，而是使用诸如QTextStream::readLine()读取一行，使用QTextStream::readAll()读取所有文本这种函数，之后再对获得的QString对象进行处理。<br>　 　默认情况下，QTextStream的编码格式是 Unicode，如果我们需要使用另外的编码，可以使用<br>　 　<code>stream.setCodec(&quot;UTF-8&quot;);</code><br>　 　这样的函数进行设置。<br>　 　另外，为方便起见，QTextStream同std::cout一样提供了很多描述符，被称为 stream manipulators。因为文本文件是供人去读的，自然需要良好的格式（相比而言，二进制文件就没有这些问题，只要数据准确就可以了）。这些描述符是一些函数的简写，我们可以从文档中找到：</p></blockquote><table><thead><tr><th>描述符</th><th>等价于</th></tr></thead><tbody><tr><td>bin</td><td>setIntegerBase(2)</td></tr><tr><td>oct</td><td>setIntegerBase(8)</td></tr><tr><td>dec</td><td>setIntegerBase(10)</td></tr><tr><td>hex</td><td>setIntegerBase(16)</td></tr><tr><td>showbase</td><td>setNumberFlags(numberFlags() / ShowBase)</td></tr><tr><td>forcesign</td><td>setNumberFlags(numberFlags() / ForceSign)</td></tr><tr><td>forcepoint</td><td>setNumberFlags(numberFlags() / ForcePoint)</td></tr><tr><td>noshowbase</td><td>setNumberFlags(numberFlags() &amp; ~ShowBase)</td></tr><tr><td>noforcesign</td><td>setNumberFlags(numberFlags() &amp; ~ForceSign)</td></tr><tr><td>noforcepoint</td><td>setNumberFlags(numberFlags() &amp; ~ForcePoint)</td></tr><tr><td>uppercasebase</td><td>setNumberFlags(numberFlags() / UppercaseBase)</td></tr><tr><td>uppercasedigits</td><td>setNumberFlags(numberFlags() / UppercaseDigits)</td></tr><tr><td>lowercasebase</td><td>setNumberFlags(numberFlags() &amp; ~UppercaseBase)</td></tr><tr><td>lowercasedigits</td><td>setNumberFlags(numberFlags() &amp; ~UppercaseDigits)</td></tr><tr><td>fixed</td><td>setRealNumberNotation(FixedNotation)</td></tr><tr><td>scientific</td><td>setRealNumberNotation(ScientificNotation)</td></tr><tr><td>left</td><td>setFieldAlignment(AlignLeft)</td></tr><tr><td>right</td><td>setFieldAlignment(AlignRight)</td></tr><tr><td>center</td><td>setFieldAlignment(AlignCenter)</td></tr><tr><td>endl</td><td>operator&lt;&lt;(‘\n’)和flush()</td></tr><tr><td>flush</td><td>flush()</td></tr><tr><td>reset</td><td>reset()</td></tr><tr><td>ws</td><td>skipWhiteSpace()</td></tr><tr><td>bom</td><td>setGenerateByteOrderMark(true)</td></tr></tbody></table><blockquote><p>　　———————————————————————–<br>　　不仅是QIODevice，QTextStream也可以直接把内容输出到QString。例如<br>　　<code>QString str;</code><br>　　<code>QTextStream(&amp;str) &lt;&lt; oct &lt;&lt; 31 &lt;&lt; &quot; &quot; &lt;&lt; dec &lt;&lt; 25 &lt;&lt; endl;</code><br>　　这提供了一种简单的处理字符串内容的方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（六）—《QT学习之路2》摘录-4（绘制系统）</title>
      <link href="/2014/11/22/learn-qt-six/"/>
      <url>/2014/11/22/learn-qt-six/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2012/10/qt-study-road-2-paint-sys/" target="_blank" rel="noopener">Qt 学习之路 2（24）：Qt 绘制系统简介</a><blockquote><p>　　Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　QPainter用来执行绘制的操作；QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。<br>　　Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。<br>　　———————————————————————-<br>　　QPainter接收一个QPaintDevice指针作为参数。QPaintDevice有很多子类，比如QImage，以及QWidget。注意回忆一下，QPaintDevice可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 this 指针。<br>　　———————————————————————-<br>　　如果了解 OpenGL，肯定听说过这么一句话：OpenGL 是一个状态机。所谓状态机，就是说，OpenGL 保存的只是各种状态。比如，将画笔颜色设置成红色，那么，除非你重新设置另外的颜色，它的颜色会一直是红色。<strong>QPainter也是这样，它的状态不会自己恢复，除非你使用了各种设置函数。</strong>因此，如果在上面的代码中，我们在椭圆绘制之后再画一个矩形，它的样式还会是绿色 5 像素的轮廓线以及蓝色的填充，除非你显式地调用了设置函数进行状态的更新。这是大多数绘图系统的实现方式，包括 OpenGL、QPainter以及 Java2D。<strong>正因为QPainter是一个状态机，才会引出我们前面曾经介绍过的一个细节问题：由于paintEvent()是需要重复进入的，因此，需要注意第二次进入时，QPainter的状态是不是和第一次一致，否则的话可能会造成闪烁的现象。这个闪烁并不是由于双缓冲的问题，而是由于绘制状态的快速切换。</strong></p></blockquote><ul><li><p><a href="http://www.devbean.net/2012/11/qt-study-road-2-brush-pen/" target="_blank" rel="noopener">Qt 学习之路 2（25）：画刷和画笔</a></p></li><li><p><a href>Qt 学习之路 2（26）：反走样</a></p><blockquote><p>　　我们在光栅图形显示器上绘制非水平、非垂直的直线或多边形边界时，或多或少会呈现锯齿状外观。这是因为直线和多边形的边界是连续的，而光栅则是由离散的点组成。在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样；用于减少或消除这种效果的技术，就称为反走样。<br>　　反走样是图形学中的重要概念，用以防止通常所说的“锯齿”现象的出现。很多系统的绘图 API 里面都内置了有关反走样的算法，不过由于性能问题，默认一般是关闭的，Qt 也不例外。<br>　　———————————————————————-<br>　　<code>painter.setRenderHint(QPainter::Antialiasing, true);</code><br>　　显然，我们通过这条语句，将Antialiasing属性（也就是反走样）设置为 true。经过这句设置，我们就打开了QPainter的反走样功能。还记得我们曾经说过，QPainter是一个状态机，因此，只要这里我们打开了它，之后所有的代码都会是反走样绘制的了。由于反走样需要比较复杂的算法，在一些对图像质量要求不是很高的应用中，是不需要进行反走样的。为了提高效率，一般的图形绘制系统，如 Java2D、OpenGL 之类都是默认不进行反走样的。<br>　　虽然反走样比不反走样的图像质量高很多，但是，没有反走样的图形绘制还是有很大用处的。首先，就像前面说的一样，在一些对图像质量要求不高的环境下，或者说性能受限的环境下，比如嵌入式和手机环境，一般是不进行反走样的。另外，在一些必须精确操作像素的应用中，也是不能进行反走样的。这是由于反走样技术本身的限制的。</p></blockquote></li><li><p><a href="http://www.devbean.net/2012/11/qt-study-road-2-coordinate-system/" target="_blank" rel="noopener">Qt 学习之路 2（28）：坐标系统</a></p></li><li><p><a href="http://www.devbean.net/2012/12/qt-study-road-2-paint-device/" target="_blank" rel="noopener">Qt 学习之路 2（29）：绘制设备</a></p><blockquote><p>　　绘图设备是继承QPainterDevice的类。QPaintDevice就是能够进行绘制的类，也就是说，QPainter可以在任何QPaintDevice的子类上进行绘制。现在，Qt 提供了若干这样的类：<br>　　<img src="http://keke-hexo-blog.qiniudn.com/image/QT/paint-device-qt5.png" alt><br>　　在 Qt5 中，QGLPixelBuffer已经被废弃。本章我们关注的是QPixmap、QBitmap、QImage和QPicture这几个类。另外的部分，QWidget就是所有组件的父类，我们已经在前面的章节中使用过，这里不再赘述。QGLWidget和QGLFramebufferObject，顾名思义，就是关于 OpenGL 的相关类。在 Qt 中，我们可以方便地结合 OpenGL 进行绘制。由于这部分需要牵扯到 OpenGL 的相关内容，现在也不再深入。在我们选择的几个类中，大多与图像密切相关。<br>　　QPixmap专门为图像在屏幕上的显示做了优化；QBitmap是QPixmap的一个子类，它的色深限定为1，你可以使用QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。QImage专门为图像的像素级访问做了优化。QPicture则可以记录和重现QPainter的各条命令。下面我们将分两部分介绍这四种绘图设备。</p></blockquote></li><li><p><a href="http://www.devbean.net/2012/12/qt-study-road-2-gvf/" target="_blank" rel="noopener">Qt 学习之路 2（30）：Graphics View Framework</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（五）—《QT学习之路2》摘录-3（事件）</title>
      <link href="/2014/11/21/learn-qt-five/"/>
      <url>/2014/11/21/learn-qt-five/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2012/09/qt-study-road-2-events/" target="_blank" rel="noopener">Qt 学习之路 2（18）：事件</a><blockquote><p>　　事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如<strong>键盘事件</strong>等；另一些事件则是由系统自动发出，如<strong>计时器事件</strong>。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　事件也就是我们通常说的“事件驱动（event drive）”程序设计的基础概念。事件的出现，使得程序代码不会按照原始的线性顺序执行。这种类似“批处理”的程序设计风格显然不适合于处理复杂的用户交互。这就是所谓的“事件驱动”，我们的程序的执行顺序不再是线性的，而是由一个个事件驱动着程序继续执行。没有事件，程序将阻塞在那里，不执行任何代码。<br>　　在 Qt 中，事件的概念似乎同信号槽类似。的确如此，一般来说，使用 Qt 组件时，我们并不会把主要精力放在事件上。因为在 Qt 中，我们关心的更多的是事件关联的一个信号。<br>　　————————————————————————-<br>　　但是，Qt 中的事件和信号槽却并不是可以相互替代的。信号由具体的对象发出，然后会马上交给由connect()函数连接的槽进行处理；而对于事件，Qt 使用一个事件队列对所有发出的事件进行维护，当新的事件产生时，会被追加到事件队列的尾部。前一个事件完成后，取出后面的事件进行处理。但是，必要的时候，Qt 的事件也可以不进入事件队列，而是直接处理。信号一旦发出，对应的槽函数一定会被执行。但是，事件则可以使用“事件过滤器”进行过滤，对于有些事件进行额外的处理，另外的事件则不关心。<strong>总的来说，如果我们使用组件，我们关心的是信号槽；如果我们自定义组件，我们关心的是事件。</strong>因为我们可以通过事件来改变组件的默认操作。<br>　　————————————————————————-<br>　　在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如keyPressEvent()、keyReleaseEvent()、mouseDoubleClickEvent()、mouseMoveEvent()、mousePressEvent()、mouseReleaseEvent()等。这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。<br>　　————————————————————————-<br>　　为什么要点击鼠标之后才能在mouseMoveEvent()函数中显示鼠标坐标值？这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。</p></blockquote><ul><li><a href="http://www.devbean.net/2012/09/qt-study-road-2-events-accept-reject/" target="_blank" rel="noopener"><strong>Qt 学习之路 2（19）：事件的接受与忽略</strong></a><blockquote><p>　　我们把父类的实现覆盖掉了。由此可以看出，父类QPushButton的mousePressEvent()函数中肯定发出了clicked()信号，否则的话，我们的槽函数怎么会不执行了呢？这暗示我们一个非常重要的细节：当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！比如我们的CustomButton了，如果像我们这么覆盖函数，clicked()信号永远不会发生，你连接到这个信号的槽函数也就永远不会被执行。这个错误非常隐蔽，很可能会浪费你很多时间才能找到。因为这个错误不会有任何提示。这一定程度上说，我们的组件“忽略”了父类的事件，但这更多的是一种违心之举，一种错误。<br>　　通过调用父类的同名函数，我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其父类传递。在事件处理函数中，可以使用isAccepted()来查询这个事件是不是已经被接收了。<strong>具体来说：如果一个事件处理函数调用了一个事件对象的accept()函数，这个事件就不会被继续传播给其父组件；如果它调用了事件的ignore()函数，Qt 会从其父组件中寻找另外的接受者。</strong><br>　　事实上，我们很少会使用accept()和ignore()函数，而是像上面的示例一样，如果希望忽略事件（所谓忽略，是指自己不想要这个事件），只要调用父类的响应函数即可。记得我们曾经说过，Qt 中的事件都是 protected 的，因此，重写的函数必定存在着其父类中的响应函数，所以，这个方法是可行的。为什么要这么做，而不是自己去手动调用这两个函数呢？因为我们无法确认父类中的这个处理函数有没有额外的操作。如果我们在子类中直接忽略事件，Qt 会去寻找其他的接收者，该子类的父类的操作会被忽略（因为没有调用父类的同名函数），这可能会有潜在的危险。<strong>为了避免自己去调用accept()和ignore()函数，而是尽量调用父类实现，Qt 做了特殊的设计：事件对象默认是 accept 的，而作为所有组件的父类QWidget的默认实现则是调用ignore()。这么一来，如果你自己实现事件处理函数，不调用QWidget的默认实现，你就等于是接受了事件；如果你要忽略事件，只需调用QWidget的默认实现。</strong>这一点我们前面已经说明。下面可以从代码级别来理解这一点，我们可以查看一下QWidget的mousePressEvent()函数的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//!!! Qt5</span><br><span class="line">void QWidget::mousePressEvent(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    event-&gt;ignore();</span><br><span class="line">    if ((windowType() == Qt::Popup)) &#123;</span><br><span class="line">        event-&gt;accept();</span><br><span class="line">        QWidget* w;</span><br><span class="line">        while ((w = QApplication::activePopupWidget()) &amp;&amp; w != this)&#123;</span><br><span class="line">            w-&gt;close();</span><br><span class="line">            if (QApplication::activePopupWidget() == w)</span><br><span class="line">                w-&gt;hide(); // hide at least</span><br><span class="line">        &#125;</span><br><span class="line">        if (!rect().contains(event-&gt;pos()))&#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>　　这段代码在 Qt4 和 Qt5 中基本一致（区别在于activePopupWidget()一行，Qt4 的版本是qApp-&gt;activePopupWidget()）。注意函数的第一个语句：event-&gt;ignore()，如果子类都没有重写这个函数，Qt 会默认忽略这个事件，继续寻找下一个事件接收者。<strong>如果我们在子类的mousePressEvent()函数中直接调用了accept()或者ignore()，而没有调用父类的同名函数，QWidget::mousePressEvent()函数中关于Popup判断的那段代码就不会被执行，因此可能会出现莫名其妙的怪异现象。</strong><br>　　————————————————————————-<br>　　<strong>这里值得注意的是，CustomButtonEx的事件传播给了父组件CustomWidget，而不是它的父类CustomButton。事件的传播是在组件层次上面的，而不是依靠类继承机制。</strong><br>　　————————————————————————-<br>　　如果你把QWidget::mousePressEvent(event)改成event-&gt;ignore()，结果也是一样的。这正如我们前面说的，QWidget的默认是调用event-&gt;ignore()。<br>　　不过，事情也不是绝对的。在一个情形下，我们必须使用accept()和ignore()函数，那就是窗口关闭的事件。注意，不要试图用前面了解到的有关accept()和ignore()的知识来理解这个事件！对于QCloseEvent事件，调用accept()意味着 Qt 会停止事件的传播，调用ignore()则意味着事件继续传播。<br>　　————————————————————————-<br>　　setWindowTitle()函数可以使用 <code>[*]</code> 这种语法来表明，在窗口内容发生改变时（通过setWindowModified(true)函数通知），Qt 会自动在标题上面的 <code>[*]</code> 位置替换成 * 号。</p></blockquote><ul><li><a href="http://www.devbean.net/2012/10/qt-study-road-2-event-func/" target="_blank" rel="noopener">Qt 学习之路 2（20）：event()</a><blockquote><p>　　前面的章节中我们曾经提到event()函数。事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。<br>　　如上所述，event()函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool CustomWidget::event(QEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    if (e-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class="line">        QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(e);</span><br><span class="line">        if (keyEvent-&gt;key() == Qt::Key_Tab) &#123;</span><br><span class="line">            qDebug() &lt;&lt; &quot;You press tab.&quot;;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return QWidget::event(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>　　CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。<strong>函数返回值是 bool 类型。如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。</strong>如果返回值是 true，并且，该事件对象设置了accept()，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。<strong>注意，在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。</strong><br>　　————————————————————————-<br>　　由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个event()函数，通过QEvent::type()判断不同的事件。鉴于重写event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了event()函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的CustomTextEdit例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。</p></blockquote><ul><li><a href="http://www.devbean.net/2012/10/qt-study-road-2-event-filter/" target="_blank" rel="noopener">Qt 学习之路 2（21）：事件过滤器</a><blockquote><p>　　有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。<br>　　通过前面的章节，我们已经知道，Qt 创建了QEvent事件对象之后，会调用QObject的event()函数处理事件的分发。显然，我们可以在event()函数中实现拦截的操作。由于event()函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个event()函数。这当然相当麻烦，更不用说重写event()函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。<br>　　QObject有一个eventFilter()函数，用于建立事件过滤器。这个函数的签名如下：<br>　　<code>virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );</code><br>　　这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。想想做化学实验时用到的过滤器，可以将杂质留到滤纸上，让过滤后的液体溜走。事件过滤器也是如此：它会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，不想让它继续转发，就返回 true，否则返回 false。事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。<br>　　eventFilter()函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用QObject::installEventFilter()函数。这个函数的签名如下：<br>　　<code>void QObject::installEventFilter ( QObject * filterObj )</code><br>　　这个函数接受一个QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是QObject的一个成员函数，因此，任意QObject都可以作为事件过滤器（问题在于，如果你没有重写eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。<br>　　我们可以向一个对象上面安装多个事件处理器，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。<br>　　还记得我们前面的那个例子吗？我们使用event()函数处理了 Tab 键。现在，我们可以给出一个使用事件过滤器的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool FilterObject::eventFilter(QObject *object, QEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    if (object == target &amp;&amp; event-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class="line">        QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(event);</span><br><span class="line">        if (keyEvent-&gt;key() == Qt::Key_Tab) &#123;</span><br><span class="line">            qDebug() &lt;&lt; &quot;You press tab.&quot;;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>　　事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。<br>　　<strong>注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃。</strong><br>　　事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p></blockquote><ul><li><p><a href="http://www.devbean.net/2012/10/qt-study-road-2-event-summary/" target="_blank" rel="noopener"><strong>Qt 学习之路 2（22）：事件总结</strong></a></p><blockquote><p>　　Qt 具有这么多种事件处理函数，肯定有一个地方对其进行分发，否则，Qt 怎么知道哪一种事件调用哪一个事件处理函数呢？这个分发的函数，就是event()。显然，当QMouseEvent产生之后，event()函数将其分发给mouseEvent()事件处理器进行处理。<br>　　event()函数会有两个问题：<br>　　1. event()函数是一个 protected 的函数，这意味着我们要想重写event()，必须继承一个已有的类。试想，我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件，一一重写其event()函数？protected 函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？<br>　　2. event()函数的确有一定的控制，不过有时候我的需求更严格一些：我希望那些组件根本看不到这种事件。event()函数虽然可以拦截，但其实也是接收到了QMouseEvent对象。我连让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。这种需求怎么办呢？<br>　　————————————————————————-<br>　　<strong>事件过滤器可以解决刚刚我们提出的event()函数的两点不足：首先，事件过滤器不是 protected 的，因此我们可以向任何QObject子类安装事件过滤器；其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将事件过滤掉，目标对象根本不会见到这个事件。</strong><br>　　事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到QCoreApplication::notify()函数，因此，最大的控制权实际上是重写QCoreApplication::notify()。这个函数的声明是：<br>　　<code>virtual bool QCoreApplication::notify ( QObject * receiver, QEvent * event );</code><br>　　该函数会将event发送给receiver，也就是调用receiver-&gt;event(event)，其返回值就是来自receiver的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，它不存在事件过滤器的线程的问题。不过我们并不推荐这么做，因为notify()函数只有一个，而事件过滤器要灵活得多。<br>　　现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：<br>　　1. 重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。<br>　　2. 重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。<br>　　3. 在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。<br>　　4. 在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。<br>　　5. 重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。<br>　　————————————————————————-<br>　　<strong>因此可以知道，全局事件过滤器被第一个调用，之后是该对象上面的事件过滤器，其次是event()函数，最后是特定的事件处理函数。</strong></p></blockquote></li><li><p><a href="http://www.devbean.net/2012/10/qt-study-road-2-custom-event/" target="_blank" rel="noopener"><strong>Qt 学习之路 2（23）：自定义事件</strong></a></p><blockquote><p>　　当然，事件也并不是局限在多线程中，它可以用在单线程的程序中，作为一种对象间通讯的机制。那么，为什么我需要使用事件，而不是信号槽呢？主要原因是，事件的分发既可以是同步的，又可以是异步的，而函数的调用或者说是槽的回调总是同步的。事件的另外一个好处是，它可以使用过滤器。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（四）—《QT学习之路2》摘录-2（对话框）</title>
      <link href="/2014/11/21/learn-qt-four/"/>
      <url>/2014/11/21/learn-qt-four/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.devbean.net/2012/09/qt-study-road-2-dialogs-intro/" target="_blank" rel="noopener">Qt 学习之路 2（13）：对话框简介</a><blockquote><p>　　Qt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。</p></blockquote></li></ul><a id="more"></a><blockquote><p>　　————————————————————————-<br>　　Qt 支持模态对话框和非模态对话框。其中，Qt 有两种级别的模态对话框：应用程序级别的模态和窗口级别的模态，默认是应用程序级别的模态。应用程序级别的模态是指，当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。窗口级别的模态是指，该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。窗口级别的模态尤其适用于多窗口模式，更详细的讨论可以看以前发表过的文章：<a href="http://www.devbean.net/2011/03/qdialog_window_modal/" target="_blank" rel="noopener">QDialog 窗口级别模态</a>。<br>　　————————————————————————-<br>　　Qt 使用QDialog::exec()实现应用程序级别的模态对话框，使用QDialog::open()实现窗口级别的模态对话框，使用QDialog::show()实现非模态对话框。<br>　　————————————————————————-<br>　　Qt 4.1 起，QWidget引入了一个新的属性windowModality，用于设置窗口是哪种类型的模态。当窗口被创建出来，windowModality会被设置为Qt::NonModal，因此默认都是非模态的。在调用QDialog::exec()之后，windowModality会被设为Qt::ApplicationModal，当exec()返回后又被设回Qt::NonModal。如果我们不自己修改windowModality的值，那么可以简单的认为其值就是由show()和exec()设置的：<br>　　QDialog::show()=&gt;Qt::NonModal<br>　　QDialog::exec()=&gt;Qt::ApplicationModal<br>　　注意，上面的映射关系并没有包括Qt::WindowModal这个值。也就是说，如果我们要设置窗口级别的模态，就要手动设置windowModality，然后再调用show()或者exec()。这当然可以，然而却与调用一个简单的函数所有不同。<br>　　————————————————————————-<br>　　由于QWidget的 parent 必须是QWidget指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置 dialog 的WindowAttribute：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    QDialog *dialog = new QDialog;</span><br><span class="line">    dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);</span><br><span class="line">    dialog-&gt;setWindowTitle(tr(&quot;Hello, dialog!&quot;));</span><br><span class="line">    dialog-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>　　setAttribute()函数设置对话框关闭时，自动销毁对话框。另外，QObject还有一个deleteLater()函数，该函数会在当前事件循环结束时销毁该对话框（具体到这里，需要使用exec()开始一个新的事件循环）。关于事件循环，我们会在后面的文章中详细说明。</p><ul><li><a href="http://www.devbean.net/2012/09/qt-study-road-2-data-between-dialogs/" target="_blank" rel="noopener">Qt 学习之路 2（14）：对话框数据传递</a><br>　　对话框的出现用于完成一个简单的或者是短期的任务。对话框与主窗口之间的数据交互相当重要。<br>　　————————————————————————-<br>　　模态对话框使用了exec()函数将其显示出来。exec()函数的真正含义是开启一个新的事件循环（我们会在后面的章节中详细介绍有关事件的概念）。所谓事件循环，可以理解成一个无限循环。Qt 在开启了事件循环之后，系统发出的各种事件才能够被程序监听到。这个事件循环相当于一种轮询的作用。既然是无限循环，当然在开启了事件循环的地方，代码就会被阻塞，后面的语句也就不会被执行到。因此，对于使用了exec()显示的模态对话框，我们可以在exec()函数之后直接从对话框的对象获取到数据值。<br>　　需要注意的一点是，如果我们设置 dialog 的属性为WA_DeleteOnClose，那么当对话框关闭时，对象被销毁，我们就不能使用这种办法获取数据了。在这种情况下，我们可以考虑使用 parent 指针的方式构建对话框，避免设置WA_DeleteOnClose属性；或者是利用另外的方式。<br>　　————————————————————————-<br>　　模态对话框相对简单，如果是非模态对话框，QDialog::show()函数会立即返回，如果我们也这么写，就不可能取得用户输入的数据。因为show()函数不会阻塞主线程，show()立即返回，用户还没有来得及输入，就要执行后面的代码，当然是不会有正确结果的。那么我们就应该换一种思路获取数据，那就是使用信号槽机制。<br>　　由于非模态对话框在关闭时可以调用QDialog::accept()或者QDialog::reject()或者更通用的QDialog::done()函数，所以我们可以在这里发出信号。另外，如果找不到合适的信号发出点，我们可以重写QDialog::closeEvent()函数，在这里发出信号。在需要接收数据的窗口（这里是主窗口）连接到这个信号即可。<br>　　————————————————————————-<br>　　不要担心如果对话框关闭，是不是还能获取到数据。因为 Qt 信号槽的机制保证，在槽函数在调用的时候，我们始终可以使用sender()函数获取到 signal 的发出者。关于sender()函数，可以在文档中找到更多的介绍。顺便说一句，sender()函数的存在使我们可以利用这个函数，来实现一个只能打开一个的非模态对话框（方法就是在对话框打开时在一个对话框映射表中记录下标记，在对话框关闭时利用sender()函数判断是不是该对话框，然后从映射表中将其删除）。</li><li><a href="http://www.devbean.net/2012/09/qt-study-road-2-standard-dialogs-qmessagebox/" target="_blank" rel="noopener">Qt 学习之路 2（15）：标准对话框 QMessageBox</a><br>　　所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。<br>　　01. Qt 的内置对话框大致分为以下几类：<br>　　02. QColorDialog：选择颜色；<br>　　03. QFileDialog：选择文件或者目录；<br>　　04. QFontDialog：选择字体；<br>　　05. QInputDialog：允许用户输入一个值，并将其值返回；<br>　　06. QMessageBox：模态对话框，用于显示信息、询问问题等；<br>　　07. QPageSetupDialog：为打印机提供纸张相关的选项；<br>　　08. QPrintDialog：打印机配置；<br>　　09. QPrintPreviewDialog：打印预览；<br>　　10. QProgressDialog：显示操作过程。<br>　　————————————————————————-<br>　　QMessageBox用于显示消息提示。我们一般会使用其提供的几个 static 函数：<br>　　void    <strong>about</strong>(QWidget <em> parent, const QString &amp; title, const QString &amp; text)<br>　　void    <strong>aboutQt</strong>(QWidget </em> parent, const QString &amp; title = QString())<br>　　StandardButton    <strong>critical</strong>(QWidget <em> parent, const QString &amp; title, const QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)<br>　　StandardButton    <strong>information</strong>(QWidget </em> parent, const QString &amp; title, const QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)<br>　　StandardButton    <strong>question</strong>(QWidget <em> parent, const QString &amp; title, const QString &amp; text, StandardButtons buttons = StandardButtons( Yes | No ), StandardButton defaultButton = NoButton)<br>　　StandardButton    <strong>warning</strong>(QWidget </em> parent, const QString &amp; title, const QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)<br>　　————————————————————————-<br>　　QMessageBox类的 static 函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。为了能够定制QMessageBox细节，我们必须使用QMessageBox的属性设置 API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox msgBox;</span><br><span class="line">msgBox.setText(tr(&quot;The document has been modified.&quot;));</span><br><span class="line">msgBox.setInformativeText(tr(&quot;Do you want to save your changes?&quot;));</span><br><span class="line">msgBox.setDetailedText(tr(&quot;Differences here...&quot;));</span><br><span class="line">msgBox.setStandardButtons(QMessageBox::Save</span><br><span class="line">                          | QMessageBox::Discard</span><br><span class="line">                          | QMessageBox::Cancel);</span><br><span class="line">msgBox.setDefaultButton(QMessageBox::Save);</span><br><span class="line">int ret = msgBox.exec();</span><br><span class="line">switch (ret) &#123;</span><br><span class="line">case QMessageBox::Save:</span><br><span class="line">    qDebug() &lt;&lt; &quot;Save document!&quot;;</span><br><span class="line">    break;</span><br><span class="line">case QMessageBox::Discard:</span><br><span class="line">    qDebug() &lt;&lt; &quot;Discard changes!&quot;;</span><br><span class="line">    break;</span><br><span class="line">case QMessageBox::Cancel:</span><br><span class="line">    qDebug() &lt;&lt; &quot;Close document!&quot;;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><a href="http://www.devbean.net/2012/09/qt-study-road-2-file-dialog/" target="_blank" rel="noopener">Qt 学习之路 2（17）：文件对话框</a><blockquote><p>　　在openFile()函数中，我们使用QFileDialog::getOpenFileName()来获取需要打开的文件的路径。这个函数具有一个长长的签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QString getOpenFileName(QWidget * parent = 0,</span><br><span class="line">                        const QString &amp; caption = QString(),</span><br><span class="line">                        const QString &amp; dir = QString(),</span><br><span class="line">                        const QString &amp; filter = QString(),</span><br><span class="line">                        QString * selectedFilter = 0,</span><br><span class="line">                        Options options = 0)</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>　　不过注意，它的所有参数都是可选的，因此在一定程度上说，这个函数也是简单的。这六个参数分别是：<br>　　parent：父窗口。我们前面介绍过，Qt 的标准对话框提供静态函数，用于返回一个模态对话框（在一定程度上这就是外观模式的一种体现）；<br>　　caption：对话框标题；<br>　　dir：对话框打开时的默认目录，“.” 代表程序运行目录，“/” 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如“C:\”等；<br>　　filter：过滤器。我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件。比如，文本编辑器希望打开文本文件，图片浏览器希望打开图片文件。过滤器就是用于过滤特定的后缀名。如果我们使用“Image Files(<em>.jpg </em>.png)”，则只能显示后缀名是 jpg 或者 png 的文件。如果需要多个过滤器，使用“;;”分割，比如“JPEG Files(<em>.jpg);;PNG Files(</em>.png)”；<br>　　selectedFilter：默认选择的过滤器；<br>　　options：对话框的一些参数设定，比如只显示文件夹等等，它的取值是enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。<br>　　QFileDialog::getOpenFileName()返回值是选择的文件路径。我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。只有当用户选择了一个文件时，我们才执行下面的操作。使用这种静态函数，在 Windows、Mac OS 上面都是直接调用本地对话框，但是 Linux 上则是QFileDialog自己的模拟。这暗示了，如果你不使用这些静态函数，而是直接使用QFileDialog进行设置，就像我们前面介绍的 QMessageBox 的设置一样，那么得到的对话框很可能与系统对话框的外观不一致。这一点是需要注意的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《决断力》（Decisive）</title>
      <link href="/2014/11/20/decisive-book-review/"/>
      <url>/2014/11/20/decisive-book-review/</url>
      
        <content type="html"><![CDATA[<p>　　书中指出人们在做决定时会不由自主地犯下四个“错误”，列举了丰富而详细的事例，给出了有效的解决方案，以帮助人们客服缺点，做出理性而果断的决定。</p><a id="more"></a><p>豆瓣读书：<a href="http://book.douban.com/subject/25744065/" target="_blank" rel="noopener">决断力</a><br>该书对应网站：<a href="http://heathbrothers.com/members/" target="_blank" rel="noopener">http://heathbrothers.com/members/</a>，注册后可下载相关资源，推荐查阅：<br><a href="http://heathbrothers.com/ot/wp-content/uploads/2013/03/The_WRAP_Process_one_pager.pdf" target="_blank" rel="noopener">The_WRAP_Process_one_pager.pdf</a>、<a href="http://heathbrothers.com/ot/wp-content/uploads/2013/03/HBDWB.pdf" target="_blank" rel="noopener">Decisive Workbook</a></p>]]></content>
      
      
      <categories>
          
          <category> 思维与心理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 决策 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（三）—《QT学习之路2》摘录-1（信号槽、moc）</title>
      <link href="/2014/11/20/learn-qt-three/"/>
      <url>/2014/11/20/learn-qt-three/</url>
      
        <content type="html"><![CDATA[<p><strong>…………………………….</strong></p><ul><li><a href="http://www.devbean.net/2012/08/qt-study-road-2-qt-intro/" target="_blank" rel="noopener">Qt 学习之路 2（2）：Qt 简介</a><blockquote><p>　　Qt 是一个著名的 C++ 应用程序框架。你并不能说它只是一个 GUI 库，因为 Qt 十分庞大，并不仅仅是 GUI 组件。使用 Qt，在一定程度上你获得的是一个“一站式”的解决方案：不再需要研究 STL，不再需要 C++ 的<string>，不再需要到处去找解析 XML、连接数据库、访问网络的各种第三方库，因为 Qt 自己内置了这些技术。</string></p></blockquote></li></ul><a id="more"></a><blockquote><p>　　————————————————————————–<br>　　Qt 和 wxWidgets 一样，也是一个标准的 C++ 库。但是它的语法类似于 Java 的 Swing，十分清晰，而且使用信号槽（signal/slot）机制，让程序看起来很明白——这也是很多人优先选择 Qt 的一个很重要的原因。不过，所谓“成也萧何，败也萧何”。这种机制虽然很清楚，但是它所带来的后果是你需要使用 Qt 的 moc 对程序进行预处理，才能够再使用标准的 make 或者 nmake 进行正常的编译，并且信号槽的调用要比普通的函数调用慢大约一个数量级（Qt 4 文档中说明该数据，但 Qt 5 尚未有官方说明）。Qt 的界面也不是原生风格的，尽管 Qt 使用 style 机制十分巧妙地模拟了原生界面。另外值得一提的是，Qt 不仅仅能够运行在桌面环境中，还可以运行在嵌入式平台以及手机平台。</p></blockquote><ul><li><p><a href="http://www.devbean.net/2012/08/qt-study-road-2-hello-world/" target="_blank" rel="noopener">Qt 学习之路 2（3）：Hello, world!</a></p><blockquote><p>　　在新版本的 Qt 中，app.exec()的实现机制确定，当最后一个可视组件关闭之后，主事件循环（也就是app.exec()）才会退出，main()函数结束（此时会销毁app）。这意味着，所有可视元素已经都关闭了，也就不存在后文提到的，QPaintDevice没有QApplication实例这种情况。</p></blockquote></li><li><p><a href="http://www.devbean.net/2012/08/qt-study-road-2-signal-slot/" target="_blank" rel="noopener">Qt 学习之路 2（4）：信号槽</a></p><blockquote><p>　　信号槽是 Qt 框架引以为豪的机制之一。熟练使用和理解信号槽，能够设计出解耦的非常漂亮的程序，有利于增强我们的技术设计能力。<br>　　所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，用自己的一个函数（成为槽（slot））来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。）</p></blockquote></li><li><p><a href="http://www.devbean.net/2012/08/qt-study-road-2-action/" target="_blank" rel="noopener">Qt 学习之路 2（8）：添加动作</a></p><blockquote><p>　　Qt 使用QAction类作为动作。顾名思义，这个类就是代表了窗口的一个“动作”，这个动作可能显示在菜单，作为一个菜单项，当用户点击该菜单项，对用户的点击做出响应；也可能在工具栏，作为一个工具栏按钮，用户点击这个按钮就可以执行相应的操作。有一点值得注意：无论是出现在菜单栏还是工具栏，用户选择之后，所执行的动作应该都是一样的。因此，Qt 并没有专门的菜单项类，只是使用一个QAction类，抽象出公共的动作。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。<br>　　QAction包含了图标、菜单文字、快捷键、状态栏文字、浮动帮助等信息。当把一个QAction对象添加到程序中时，Qt 自己选择使用哪个属性来显示，无需我们关心。同时，Qt 能够保证把QAction对象添加到不同的菜单、工具栏时，显示内容是同步的。也就是说，如果我们在菜单中修改了QAction的图标，那么在工具栏上面这个QAction所对应的按钮的图标也会同步修改。<br>　　————————————————————————–<br>　　QIcon的参数，以 <strong>:</strong> 开始，意味着从资源文件中查找资源。:/images/doc-open就是找到了这里的 document-open.png 这个文件。（我们使用的是 png 格式的图片，这是 Qt 内置支持的图片格式。其他格式的图片，比如 jpg、gif 则需要插件支持。这些插件实际已经随着 Qt 一同发布。）<br>　　————————————————————————–<br>　　下面一句，我们使用了setShortcut()函数，用于说明这个QAction的快捷键。Qt 的QKeySequence为我们定义了很多内置的快捷键，比如我们使用的 Open。你可以通过查阅 API 文档获得所有的快捷键列表。 这个与我们自己定义的有什么区别呢？简单来说，我们完全可以自己定义一个tr(“Ctrl+O”)来实现快捷键。原因在于，这是 Qt 跨平台性的体现。比如 PC 键盘和 Mac 键盘是不一样的，一些键在 PC 键盘上有，而 Mac 键盘上可能并不存在，或者反之。使用QKeySequence类来添加快捷键，会根据平台的不同来定义相应的快捷键。</p></blockquote></li><li><p><a href="http://www.devbean.net/2012/08/qt-study-road-2-resource-files/" target="_blank" rel="noopener">Qt 学习之路 2（9）：资源文件</a></p><blockquote><p>　　Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。<br>　　————————————————————————–<br>　　如果以后我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息。这样，我们可以直接使用:/images/doc-open引用到这个资源，无需关心图片的真实文件名。<br>　　————————————————————————–<br>　　如果仔细观察，还会看到资源编辑窗口最下方有一个“语言”。这个可以对资源进行国际化。比如我们新建一个前缀，将语言设置为 fr，再添加一个文件 document-open-fr.png。我们可以使用:/images/fr/doc-open引用到 document-open-fr.png 这个文件。这个“语言”的作用是，如果 Qt 发现，本机的本地化信息是 fr 的话（QLocale::system().name()返回 fr_FR），则使用:/images/fr/doc-open这个图片；如果不是，则默认使用:/images/doc-open这个。</p></blockquote></li><li><p><a href="http://www.devbean.net/2012/09/qt-study-road-2-objects-model/" target="_blank" rel="noopener">Qt 学习之路 2（10）：对象模型</a></p><blockquote><p>　　标准 C++ 对象模型在运行时效率方面卓有成效，但是在某些特定问题域下的静态特性就显得捉襟见肘。GUI 界面需要同时具有运行时的效率以及更高级别的灵活性。为了解决这一问题，Qt “扩展”了标准 C++。所谓“扩展”，实际是在使用标准 C++ 编译器编译 Qt 源程序之前，Qt 先使用一个叫做 <strong>moc</strong>（Meta Object Compiler，元对象编译器）的工具，先对 Qt 源代码进行一次预处理（注意，这个预处理与标准 C++ 的预处理有所不同。Qt 的 moc 预处理发生在标准 C++ 预处理器工作之前，并且 Qt 的 moc 预处理不是递归的。），生成标准 C++ 源代码，然后再使用标准 C++ 编译器进行编译。如果你曾经为信号函数这样的语法感到奇怪（现在我们已经编译过一些 Qt 程序，你应当注意到了，信号函数是不需要编写实现代码的，那怎么可以通过标准 C++ 的编译呢？），这其实就是 moc 进行了处理之后的效果。<br>　　Qt 使用 moc，为标准 C++ 增加了一些特性：<br>　　1. 信号槽机制，用于解决对象之间的通讯，这个我们已经了解过了，可以认为是 Qt 最明显的特性之一；<br>　　2. 可查询，并且可设计的对象属性；<br>　　3. 强大的事件机制以及事件过滤器；<br>　　4. 基于上下文的字符串翻译机制（国际化），也就是 tr() 函数，我们简单地介绍过；<br>　　5. 复杂的定时器实现，用于在事件驱动的 GUI 中嵌入能够精确控制的任务集成；<br>　　6. 层次化的可查询的对象树，提供一种自然的方式管理对象关系。<br>　　7. 智能指针（QPointer），在对象析构之后自动设为 0，防止野指针；<br>　　8. 能够跨越库边界的动态转换机制。<br>　　通过继承QObject类，我们可以很方便地获得这些特性。当然，这些特性都是由 moc 帮助我们实现的。moc 其实实现的是一个叫做元对象系统（meta-object system）的机制。正如上面所说，这是一个标准 C++ 的扩展，使得标准 C++ 更适合于进行 GUI 编程。虽然利用模板可以达到类似的效果，但是 Qt 没有选择使用模板。按照 Qt 官方的说法，模板虽然是内置语言特性，但是其语法实在是复杂，并且由于 GUI 是动态的，利用静态的模板机制有时候很难处理。而自己使用 moc 生成代码更为灵活，虽然效率有些降低（一个信号槽的调用大约相当于四个模板函数调用），不过在现代计算机上，这点性能损耗实在是可以忽略。<br>　　————————————————————————–<br>　　QObject是以对象树的形式组织起来的。当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是 parent，也就是父对象指针。这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。<br>　　QWidget是能够在屏幕上显示的一切组件的父类。QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。<br>　　当然，我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。<br>　　我们可以使用QObject::dumpObjectTree()和QObject::dumpObjectInfo()这两个函数进行这方面的调试。<br>　　Qt 引入对象树的概念，在一定程度上解决了内存问题。<br>　　当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。Qt 保证的是，任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。<br>　　如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。来看下下面的代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QWidget window;</span><br><span class="line">    QPushButton quit(&quot;Quit&quot;, &amp;window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>　　作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++ （ISO/IEC 14882:2003）要求，局部对象的析构顺序应该按照其创建顺序的相反过程。因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。<br>　　但是，如果我们使用下面的代码：　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QPushButton quit(&quot;Quit&quot;);</span><br><span class="line">    QWidget window;</span><br><span class="line">    quit.setParent(&amp;window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>　　情况又有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，C++ 不允许调用两次析构函数，因此，程序崩溃了。<br>　　<strong>由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情</strong>。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯，<strong>在 Qt 中，尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT学习之路2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（二）— 初探</title>
      <link href="/2014/11/15/learn-qt-two/"/>
      <url>/2014/11/15/learn-qt-two/</url>
      
        <content type="html"><![CDATA[<h2 id="QT-UI的选择"><a href="#QT-UI的选择" class="headerlink" title="QT UI的选择"></a>QT UI的选择</h2><p>我们主要使用QT构建界面，QT5有三种方法，各有其适用场合，详见官方介绍：<br>三种界面介绍：<a href="http://qt-project.org/doc/qt-5/topics-ui.html" target="_blank" rel="noopener">User Interfaces</a><br>类似于MFC的传统界面：<a href="http://qt-project.org/doc/qt-5/qtwidgets-index.html" target="_blank" rel="noopener">Qt Widgets</a>、<a href="http://qt-project.org/doc/qt-5/qtdesigner-manual.html" target="_blank" rel="noopener">Qt Designer Manual</a><br>使用QML语言创建的类似网页的界面，有丰富的特效：<a href="http://qt-project.org/doc/qt-5/qtquick-index.html" target="_blank" rel="noopener">Qt Quick</a>、<a href="http://qt-project.org/doc/qtcreator-3.2/creator-using-qt-quick-designer.html" target="_blank" rel="noopener">Using Qt Quick Designer</a><br>专用于呈现网页内容：<a href="http://qt-project.org/doc/qt-5/qtwebkit-index.html" target="_blank" rel="noopener">Qt WebKit</a>、<a href="http://qt-project.org/doc/qt-5/qtwebkitwidgets-index.html" target="_blank" rel="noopener">Qt WebKit Widgets</a><br>而QT Creator使用了这三种界面。</p><a id="more"></a><h2 id="qApp，对应于MFC中的theApp"><a href="#qApp，对应于MFC中的theApp" class="headerlink" title="qApp，对应于MFC中的theApp"></a>qApp，对应于MFC中的theApp</h2><p>在<code>qapplication.h</code>文件中有定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if defined(qApp)</span><br><span class="line">#undef qApp</span><br><span class="line">#endif</span><br><span class="line">#define qApp (static_cast&lt;QApplication *&gt;(QCoreApplication::instance()))</span><br></pre></td></tr></table></figure></p><h2 id="QT5相对于QT4的一些注意事项"><a href="#QT5相对于QT4的一些注意事项" class="headerlink" title="QT5相对于QT4的一些注意事项"></a>QT5相对于QT4的一些注意事项</h2><ul><li>在 QT4 中常写的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(&amp;button, SIGNAL(clicked()), &amp;app, SLOT(quit()));</span><br></pre></td></tr></table></figure></li></ul><p>在 QT5 中应该改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit);</span><br></pre></td></tr></table></figure></p><p>请参考：<a href="http://www.devbean.net/2012/08/qt-study-road-2-signal-slot/" target="_blank" rel="noopener">Qt 学习之路 2（4）：信号槽</a><br>摘录：</p><blockquote><p>QT4 中使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意，即使quit()是QApplication的 static 函数，也必须传入一个对象指针。这也是 Qt 4 的信号槽语法的局限之处。另外，注意到connect()函数的 signal 和 slot 都是接受字符串，因此，不能将全局函数或者 Lambda 表达式传入connect()。一旦出现连接不成功的情况，Qt 4 是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。但是，如果你使用了 Qt5 的新语法，新语法提供了编译期检查（取函数指针）。</p></blockquote><ul><li><p>QT5 中自定义信号槽时，槽函数不需要加<code>public slots:</code>，但是 QT4 必须要加。<br>请参考：<a href="http://www.devbean.net/2012/08/qt-study-road-2-custom-signal-slot/" target="_blank" rel="noopener">Qt 学习之路 2（5）：自定义信号槽</a></p></li><li><p><a href="http://www.devbean.net/2012/09/qt-study-road-2-deep-qt5-signals-slots-syntax/" target="_blank" rel="noopener">Qt 学习之路 2（16）：深入 Qt5 信号槽新语法</a></p></li><li><p>QT4 中的 QtGui 当于 Qt5 的 QtGui 与 QtWidgets 两个模块的总和，所以当程序或教程是针对 QT4 的，迁移到 QT5 时要添加 QtWidgets 包含。<br>请参考：<a href="http://www.devbean.net/2012/08/qt-study-road-2-modules/" target="_blank" rel="noopener">Qt 学习之路 2（6）：Qt 模块简介</a><br>摘录：</p><blockquote><p>“槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响”，public、private 这些修饰符是供编译器在编译期检查的，因此其影响在于编译期。对于 Qt4 的信号槽连接语法，其连接是在运行时完成的，因此即便是 private 的槽函数也是可以作为槽进行连接的。但是，如果你使用了 Qt5 的新语法，新语法提供了编译期检查（取函数指针），因此取 private 函数的指针是不能通过编译的。</p></blockquote></li></ul><h2 id="QT-BEGIN-NAMESPACE和前向声明"><a href="#QT-BEGIN-NAMESPACE和前向声明" class="headerlink" title="QT_BEGIN_NAMESPACE和前向声明"></a>QT_BEGIN_NAMESPACE和前向声明</h2><p><a href="http://qt-project.org/forums/viewthread/23207" target="_blank" rel="noopener"><strong>QT_BEGIN_NAMESPACE</strong></a><br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT_BEGIN&amp;&amp;END_NAMESPACE.png" alt></p><p>From stackoverflow: <a href="http://stackoverflow.com/questions/553682/when-can-i-use-a-forward-declaration" target="_blank" rel="noopener">When can I use a forward declaration?</a></p><p>QT实例代码使用了好多前向声明代替过早包含过多头文件导致的编译依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; You might wonder why we don&apos;t include &lt;QtGui&gt; in mainwindow.h and be done with it. </span><br><span class="line">&gt; The reason is that including such a large header from another header file can rapidly degrade performances. </span><br><span class="line">&gt; Here, it wouldn&apos;t do any harm, but it&apos;s still generally a good idea to include only the header files that are strictly necessary from another header file.</span><br></pre></td></tr></table></figure></p><h2 id="QString"><a href="#QString" class="headerlink" title="QString"></a>QString</h2><p>成员函数命名与STL一致，实现了STL string类的功能（不知道是不是所有的），兼有微软MFC库中CString的功能，并且扩展了许多其他功能的成员函数，功能十分强大。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p><a href="http://www.devbean.net/2012/06/cpp11-in-qt4/" target="_blank" rel="noopener">在 Qt4 中使用 C++11</a><br><a href="http://www.cnblogs.com/rollenholt/articles/2546165.html" target="_blank" rel="noopener">Qt5 中对 C++11 一些新特性的封装</a></p><h2 id="QT之在堆（heap）或栈（stack）上创建对象"><a href="#QT之在堆（heap）或栈（stack）上创建对象" class="headerlink" title="QT之在堆（heap）或栈（stack）上创建对象"></a>QT之在<code>堆（heap）</code>或<code>栈（stack）</code>上创建对象</h2><p>QT有规定“记住，你应该总是堆上构造QObject对象，且绝不要去拷贝它们”：</p><p><a href="http://stackoverflow.com/questions/3503041/in-qt-we-uses-more-pointers-is-there-any-advantages" target="_blank" rel="noopener">in Qt we uses more pointers, is there any advantages?</a><br><a href="http://stackoverflow.com/questions/3412579/should-non-qobject-derived-classes-always-be-put-on-the-stack/3413523#3413523" target="_blank" rel="noopener">Should non-QObject derived classes “always” be put on the stack?</a></p><p><a href="http://qt-project.org/forums/viewthread/20502" target="_blank" rel="noopener">[SOLVED] Does QObject distinguish between stack and heap allocated children?</a><br><a href="http://qt-project.org/forums/viewthread/8803" target="_blank" rel="noopener">[Solved] QWidget assumes allocation on heap, not stack?</a><br><a href="http://qt-project.org/forums/viewthread/17011" target="_blank" rel="noopener">c++ QObject’s Child Management</a></p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习QT（一）—下载安装与设置</title>
      <link href="/2014/11/15/learn-qt-one/"/>
      <url>/2014/11/15/learn-qt-one/</url>
      
        <content type="html"><![CDATA[<h2 id="为何学习QT"><a href="#为何学习QT" class="headerlink" title="为何学习QT"></a>为何学习QT</h2><ol><li><p><strong>先看看各种GUI库的比较</strong>：<a href="http://devbean.blog.51cto.com/448512/175190/" target="_blank" rel="noopener">wxWidgets与其他工具库的比较(上)</a>、<a href="http://devbean.blog.51cto.com/448512/183119" target="_blank" rel="noopener">wxWidgets与其他工具库的比较(下)</a></p></li><li><p><strong>知乎关于QT前景的讨论</strong>：<a href="http://www.zhihu.com/question/19689965" target="_blank" rel="noopener">Qt的前景如何？Qt for Android 好吗？</a></p></li></ol><a id="more"></a><ol start="3"><li><strong>个人感受</strong><br>　　总的说来，QT的优点是：更加面向对象，写出来的程序代码简洁清晰；缺点是：不是Native界面，且由于机制原因，编译和运行速度有点慢，不过现在配置相对比较高，大家连Java和C#的速度都可以忍受，这一点不足为虑。<br>　　个人通过简短的使用，发现QT Creator比VS更快速，设计得也更易用，该有的功能都有，不像VS那么臃肿；QT的信号（Signal）与槽（Slot）机制比MFC的消息机制更易懂。个人认为QT的适用对象和场合为：<blockquote><p>C++的忠实粉丝（喜欢C++的人通常会喜欢上基于C++的QT，用QT Widgets做UI写出的代码很优美）；<br>习惯使用MFC的程序员（QT Widgets与MFC一样易用，但是没有MFC那么杂乱）；<br>需要编写跨平台程序（QT应该是目前跨的平台最多的UI库，规模也较大，易用、有保障）；<br>需要编写Linux程序（QT Creator+QT可以媲美Windows上的VS+MFC）；<br>打算自己编写开源程序（可以使用QT5和C++11/14最新特性，写出跨平台的开源程序）；</p></blockquote></li></ol><p>　　不过好多时候给别人做软件时，考虑到兼容性和风险，都被指定了特定版本的IDE或类库，只有在自己构建小型开源项目时可以一直追求最新的标准、最新的类库。</p><h2 id="QT学习资料"><a href="#QT学习资料" class="headerlink" title="QT学习资料"></a>QT学习资料</h2><p>知乎文章：<a href="http://www.zhihu.com/question/23717444" target="_blank" rel="noopener">有哪些Qt博客写得好值得推荐看看？</a><br>From Quora: <a href="https://www.quora.com/How-should-I-start-learning-Qt" target="_blank" rel="noopener">How should I start learning Qt?</a></p><p><a href="http://bbs.qter.org/forum.php?mod=viewthread&amp;tid=193" target="_blank" rel="noopener">Qt快速入门系列教程目录</a><br><a href="http://devbean.blog.51cto.com/448512/d-8" target="_blank" rel="noopener">Qt - 豆子空间</a>、<a href="http://www.devbean.net/category/qt-study-road-2/" target="_blank" rel="noopener">Qt 学习之路 2（目前在看，强烈建议，基于QT5，用法地道）</a><br><a href="http://blog.csdn.net/dbzhang800/article/details/6300789" target="_blank" rel="noopener">1+1=2的 blog 文章索引</a>、<a href="http://blog.debao.me/" target="_blank" rel="noopener">1+1=2（英文）</a><br><a href="http://www.dushibaiyu.com/category/code/jichu/qt-jichu" target="_blank" rel="noopener">Qt | 渡世白玉</a>、<a href="http://blog.sina.com.cn/s/articlelist_2801495241_2_1.html" target="_blank" rel="noopener">Qt_一去丶二三里_新浪博客</a></p><p>官方：<br><a href="https://qt-project.org/wiki/Developer-Guides" target="_blank" rel="noopener">Qt Developer Guides</a>、<a href="http://qt-project.org/wiki" target="_blank" rel="noopener">QT wiki</a><br><a href="http://qt-project.org/wiki/gettingstartedqtChinese" target="_blank" rel="noopener">Qt编程入门（不建议看，基于QT4讲的，有些用法已经被淘汰）</a>、<a href="http://qt-project.org/wiki/gettingstartqmlChinese" target="_blank" rel="noopener">QML编程入门</a><br>迁移相关：<br><a href="http://qt-project.org/doc/qt-4.8/porting4.html" target="_blank" rel="noopener">Porting to Qt 4</a>、<a href="http://qt-project.org/wiki/Transition_from_Qt_4.x_to_Qt5" target="_blank" rel="noopener">The Transition from Qt 4.x to Qt 5</a><br><a href="http://doc.qt.digia.com/solutions/qtwinmigrate/index.html" target="_blank" rel="noopener">Qt/MFC Migration Framework</a></p><p>其他：<a href="http://qmlbook.org/" target="_blank" rel="noopener">A Book about Qt5</a>、<a href="http://www.digitalfanatics.org/projects/qt_tutorial/" target="_blank" rel="noopener">The Independent Qt® Tutorial</a>、<a href="http://blog.qt.digia.com/" target="_blank" rel="noopener">QT blog</a></p><p>介绍QT的相关书籍：<a href="http://qt-project.org/books" target="_blank" rel="noopener">http://qt-project.org/books</a></p><h2 id="选择QT-SDK"><a href="#选择QT-SDK" class="headerlink" title="选择QT SDK"></a>选择QT SDK</h2><p>进入下载页面：<a href="http://www.qt.io/download-open-source/#" target="_blank" rel="noopener">http://www.qt.io/download-open-source/#</a>，点击“View All Downloads”展开所有下载链接，个人一般下载“Qt 5.3.2 for Windows 32-bit (MinGW 4.8.2, 737.4 MB)”，其中含有QT Creator。</p><h2 id="QT-Creator配置"><a href="#QT-Creator配置" class="headerlink" title="QT Creator配置"></a>QT Creator配置</h2><ul><li><p><strong>将“字型”改为“Monaco”，“配色方案”改为“Inkpot”</strong><br>位置：“工具”-“选项”-“文本编辑器”-“字体和颜色”<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator-字体和颜色.png" alt></p></li><li><p><strong>勾选“高亮显示当前行”和“高亮显示段落”</strong><br>位置：“工具”-“选项”-“文本编辑器”-“显示”<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator-高亮显示.png" alt><br>效果如下（非当前行所在区块会被淡化以突出当前区块代码）：<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator-高亮显示效果.png" alt></p></li></ul><h2 id="QT-Creator使用"><a href="#QT-Creator使用" class="headerlink" title="QT Creator使用"></a>QT Creator使用</h2><p>首先，不得不赞一个，QT的文档做的很好，与QT Creator很好地集成在了一起，很容易上手。</p><ul><li><strong>QT-欢迎</strong><br>点击左侧的“QT欢迎”标签进入欢迎界面：<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator-欢迎.png" alt></li></ul><p>可以点击“示例”按钮后选择一个示例，IDE打开项目的同时会弹出一个窗口，里面有该示例的详细说明，这些源码和说明文档都位于本地的QT安装目录中：<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator-Application Example.png" alt></p><p>可以点击“Get Started Now”按钮进入帮助页面，这里包含QT各方面的文档（位于QT安装目录）：<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator-Getting Started.png" alt></p><ul><li><p><strong>QT帮助</strong><br>点击左侧的“帮助”标签可进入帮助页面，该帮助类似于VS的离线MSDN，但是被很好地集成在了QT Creator中，有着很强大的搜索功能，可以添加并查找书签，并且排版优于CHM格式的MSDN，使用起来感觉很流畅。<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator帮助.png" alt></p></li><li><p><strong>左边栏</strong><br>左边栏上侧常用于显示“项目”（项目文件结构，类似于VS的“解决方案资源管理器”）、“类视图”（整个项目的类结构，类似于VS的“类视图”）、“大纲”（当前激活文件内的变量、函数、类，类似于Visual Assist的“VA Outline”），而下侧一般用于显示“打开文档”（类似于VS的打开文件标签，不过更强大，右击就可以看到）：<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator左边栏.png" alt></p></li><li><p><strong>导航栏</strong><br>左上角的“返回”、“前进”是我常用的工具栏按钮，放在这里用起来很方便。<br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator上侧导航栏.png" alt></p></li><li><p><strong>输出栏</strong><br><img src="http://keke-hexo-blog.qiniudn.com/image/QT/QT Creator下侧调试结果显示.png" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QT Creator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo和Gitcafe搭建个人博客</title>
      <link href="/2014/11/01/setup-blog-with-hexo/"/>
      <url>/2014/11/01/setup-blog-with-hexo/</url>
      
        <content type="html"><![CDATA[<p>　　之前找工作，经常逛<a href="http://www.itmian4.com/" target="_blank" rel="noopener">IT面试</a>网站，一次循着一篇文章找到了<a href="http://wuchong.me/" target="_blank" rel="noopener">Jark’s Blog</a>，感觉界面很清爽，访问速度很快，就打算自己也开一个这样的博客。</p><a id="more"></a><h2 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h2><p>　　本博客用<a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>+<a href="https://gitcafe.com/" target="_blank" rel="noopener">Gitcafe</a>搭建，博客内容需要用<a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown</a>编写。总体来说有点麻烦，但是具有高度的自由度。</p><p>　　Hexo的由来参见作业的博文：<a href="http://zespia.tw/blog/2012/10/11/hexo-debut/" target="_blank" rel="noopener">Hexo 颯爽登場！</a>。其他介绍：<a href="http://lucifr.com/2013/01/02/from-octopress-to-hexo/" target="_blank" rel="noopener">从 Octopress 到 Hexo</a>、<a href="http://www.cnblogs.com/youxilua/archive/2013/04/04/2999026.html" target="_blank" rel="noopener">Hexo 简明入门教程（一）</a>。</p><p>　　如果不想从博客园转过来，但是喜欢Hexo风格主题的，也可以参考：<a href="http://www.cnblogs.com/moondark/p/3607825.html" target="_blank" rel="noopener">将博客园界面打造成Hexo经典主题Light</a>。Hexo还支持导入其他博客的博文：<a href="http://jingyan.baidu.com/article/5bbb5a1b34bd1d13eaa1797e.html" target="_blank" rel="noopener">从博客园迁移到Hexo</a>、<a href="http://blog.yidongzhifu.net/2014/03/25/%E6%8A%9B%E5%BC%83wordpress%E6%AD%A3%E5%BC%8F%E7%94%A8hexo-%E8%BF%81%E5%BE%99%E4%B9%8B%E8%B7%AF/" target="_blank" rel="noopener">抛弃Wordpress正式用Hexo-迁徙之路</a>。</p><h2 id="购买并设置域名（可选）"><a href="#购买并设置域名（可选）" class="headerlink" title="购买并设置域名（可选）"></a>购买并设置域名（可选）</h2><p>　　专属域名首先比较个性，从长远来看，当网站访问量比较大时，还可以拿来谋点财富。之所以先谈域名购买，是因为域名购买后有一个生效时间。如果不打算购买，可以跳过。</p><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>　　大家都选国外的<a href="https://www.godaddy.com/" target="_blank" rel="noopener">Godaddy</a>网站（至于原因，自行谷歌去），<a href="http://www.angely.org/godaddy" target="_blank" rel="noopener">点此</a>可以找到优惠码或优惠链接，首选com和me域名，年费60元左右，图文购买教程见：<a href="http://www.admin5.com/article/20131014/527495.shtml" target="_blank" rel="noopener">2013年10月新版godaddy域名注册图文教程</a>。</p><h3 id="更改域名默认的DNS"><a href="#更改域名默认的DNS" class="headerlink" title="更改域名默认的DNS"></a>更改域名默认的DNS</h3><p>　　在Godaddy上购买的域名默认使用的是国外的DNS来解析的，我们在国内，为了解析速度，需要找一个国内的DNS，大家都选<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSPod</a>，<a href="https://www.dnspod.cn/Plans/Buy#personal" target="_blank" rel="noopener">免费版</a>就够用了，具体步骤见图文教程：<a href="http://www.admin5.com/article/20131014/527502.shtml" target="_blank" rel="noopener">2013年10月新版godaddy更改DNS服务器</a>。DNSPod的免费DNS为<code>f1g1ns1.dnspod.net</code>和<code>f1g1ns2.dnspod.net</code>，参见：<a href="https://support.dnspod.cn/Kb/showarticle/?qtype=%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&amp;tsid=178" target="_blank" rel="noopener">DNSPod各个套餐的DNS地址</a>。全球DNS服务器同步完成最多需要72个小时。如果运气好，也许不到一天，国内就都可以正常访问了。我的运气比较好，不到一小时就可以用了。</p><h3 id="在DNSPod添加域名和记录"><a href="#在DNSPod添加域名和记录" class="headerlink" title="在DNSPod添加域名和记录"></a>在DNSPod添加域名和记录</h3><p>　　具体步骤见图文教程：<a href="https://support.dnspod.cn/Kb/showarticle/tsid/177/" target="_blank" rel="noopener">学会使用DNSPod，仅需三步</a>。<br>　　这里说下“添加记录”，Gitcafe的记录值为：<code>117.79.146.98</code>（参见：<a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9" target="_blank" rel="noopener">如何创建Page和绑定域名</a>），Github的记录值为：<code>192.30.252.153</code>和<code>192.30.252.154</code>（参见：<a href="https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/" target="_blank" rel="noopener">Tips for configuring an A record with your DNS provider</a>），如下图所示：<img src="http://keke-hexo-blog.qiniudn.com/image/DNSPod添加记录.png" alt></p><h2 id="安装Hexo并初始化博客本地文件夹"><a href="#安装Hexo并初始化博客本地文件夹" class="headerlink" title="安装Hexo并初始化博客本地文件夹"></a>安装Hexo并初始化博客本地文件夹</h2><h3 id="安装分三个步骤："><a href="#安装分三个步骤：" class="headerlink" title="安装分三个步骤："></a>安装分三个步骤：</h3><blockquote><ul><li>安装 Git</li><li>安装 Node.js</li><li>安装 Hexo</li></ul></blockquote><p>参见官方教程：<a href="http://hexo.io/docs/index.html" target="_blank" rel="noopener">点击进入</a></p><h3 id="初始化本地博客文件夹："><a href="#初始化本地博客文件夹：" class="headerlink" title="初始化本地博客文件夹："></a>初始化本地博客文件夹：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt; folder &gt;</span><br><span class="line">$ cd &lt; folder &gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>参见官方教程：<a href="http://hexo.io/docs/setup.html" target="_blank" rel="noopener">点击进入</a></p><h2 id="设置Git以便可以访问Github和Gitcafe"><a href="#设置Git以便可以访问Github和Gitcafe" class="headerlink" title="设置Git以便可以访问Github和Gitcafe"></a>设置Git以便可以访问Github和Gitcafe</h2><p>　　Git会根据用户的名字和邮箱来记录提交。YOUR NAME作为名称凭证，一般用真实姓名；YOUR EMAIL ADDRESS需要与登陆Github（Gitcafe）的邮箱名相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;YOUR NAME&quot;</span><br><span class="line">$ git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;</span><br></pre></td></tr></table></figure></p><p>参见：<a href="https://help.github.com/articles/set-up-git/" target="_blank" rel="noopener">Set Up Git</a></p><h2 id="生成SSH公钥"><a href="#生成SSH公钥" class="headerlink" title="生成SSH公钥"></a>生成SSH公钥</h2><p>　　生成与计算机对应的SSH公钥，用于将Hexo生成的静态本地博客数据远程上传到Github或Gitcafe上。详见Github教程：<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="noopener">Generating SSH keys</a></p><p>　　添加公钥到ssh-agent出错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa.pub</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure></p><p>　　解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval `ssh-agent`;ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p><p>　　参考：<a href="http://stackoverflow.com/questions/17846529/could-not-open-a-connection-to-your-authentication-agent" target="_blank" rel="noopener">Could not open a connection to your authentication agent</a></p><h2 id="注册Github或Gitcafe、建立pages、绑定域名"><a href="#注册Github或Gitcafe、建立pages、绑定域名" class="headerlink" title="注册Github或Gitcafe、建立pages、绑定域名"></a>注册Github或Gitcafe、建立pages、绑定域名</h2><p>　　该类型的博客是借助Github和Gitcafe的pages功能来将Markdown显示为网页的，而pages功能的出发点用于建立托管项目主页。</p><h3 id="Github设置："><a href="#Github设置：" class="headerlink" title="Github设置："></a>Github设置：</h3><p>详情参考：<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="noopener">hexo你的博客</a>、<a href="http://beiyuu.com/github-pages/" target="_blank" rel="noopener">使用Github Pages建独立博客</a>、<a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">Setting up a custom domain with GitHub Pages</a></p><h3 id="Gitcafe设置："><a href="#Gitcafe设置：" class="headerlink" title="Gitcafe设置："></a>Gitcafe设置：</h3><p>详情参考：<a href="http://zipperary.com/2013/11/23/hexo-to-gitcafe/" target="_blank" rel="noopener">托管博客到gitcafe</a>、<a href="http://magiclin.com/2013/12/20/hexo-gitcafe/" target="_blank" rel="noopener">部署Hexo静态blog到gitcafe</a>，还有Gitcafe官方帮助：<a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9" target="_blank" rel="noopener">如何创建Page和绑定域名</a></p><h3 id="还有其他一些教程："><a href="#还有其他一些教程：" class="headerlink" title="还有其他一些教程："></a>还有其他一些教程：</h3><p><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="noopener">使用hexo搭建博客</a>、<a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="noopener">如何搭建一个独立博客——简明Github Pages与Hexo教程</a>、<a href="http://www.freehao123.com/gitcafe/" target="_blank" rel="noopener">GitCafe国内在线托管软件项目平台申请试用:附与Github简单比较</a></p><h2 id="同时使用GitHub和GitCafe"><a href="#同时使用GitHub和GitCafe" class="headerlink" title="同时使用GitHub和GitCafe"></a>同时使用GitHub和GitCafe</h2><p>　　配置使得国外访问Github、国内访问Gitcafe。</p><p>　　在DNSPod上的域名解析设置参考：<a href="http://www.tuicool.com/articles/2yiMVjZ" target="_blank" rel="noopener">同时使用 GitHub 和 GitCafe 托管 octopress</a></p><p>　　Hexo参数配置参考：<a href="http://hexo.io/docs/deployment.html#Git" target="_blank" rel="noopener">官方文档</a>，下面是我的部署配置（_config.yml)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">   github: git@github.com:keke2014/keke2014.github.io.git</span><br><span class="line">   gitcafe: git@gitcafe.com:keke2014/keke2014.git,gitcafe-pages</span><br></pre></td></tr></table></figure><h2 id="Github与Gitcafe比较"><a href="#Github与Gitcafe比较" class="headerlink" title="Github与Gitcafe比较"></a>Github与Gitcafe比较</h2><p>　　</p><blockquote><ul><li>Github项目多、大牛多，但是国内访问速度稍逊；Gitcafe国内访问速度很快，域名绑定方便。</li><li>Github单个项目最大空间限制为1GB、单个文件不得大于100MB，而且好像不支持付费购买，等博客内容累计到大于1GB就不好办了，参考：<a href="https://help.github.com/articles/what-is-my-disk-quota/" target="_blank" rel="noopener">What is my disk quota?</a>、<a href="https://github.com/pricing" target="_blank" rel="noopener">Plans and pricing</a>；Gitcafe每个账户免费赠送 512 MB 托管空间，在超出免费使用空间后后，超出部分每 512 MB 每天需支付 4 GitCoin，参见：<a href="https://gitcafe.com/GitCafe/Help/wiki/GitCafe-%E8%B4%A6%E6%88%B7%E6%9D%83%E9%99%90%E4%B8%8E%E6%94%B6%E8%B4%B9%E8%A7%84%E5%88%99#wiki" target="_blank" rel="noopener">GitCafe 账户权限与收费规则</a>。</li></ul></blockquote><h2 id="附件存储"><a href="#附件存储" class="headerlink" title="附件存储"></a>附件存储</h2><p>　　Github和Gitcafe空间有限，较大的附件和图片需要放到其他地方，首选<a href="https://portal.qiniu.com/signup" target="_blank" rel="noopener">七牛云</a>，对于个人博客免费版足够了，而且身份认证后可以升级为标准版（具有更大的空间、更多的流量）。这是我的邀请链接：<a href="https://portal.qiniu.com/signup?code=3llqzksdajln6" target="_blank" rel="noopener">https://portal.qiniu.com/signup?code=3llqzksdajln6</a></p><h2 id="Markdown编辑器"><a href="#Markdown编辑器" class="headerlink" title="Markdown编辑器"></a>Markdown编辑器</h2><h3 id="在线的"><a href="#在线的" class="headerlink" title="在线的"></a>在线的</h3><blockquote><ul><li><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd - 在线 Markdown 编辑阅读器</a></li><li><a href="http://mahua.jser.me/" target="_blank" rel="noopener">MaHua 在线 Markdown 编辑器</a></li><li><a href="http://maxiang.info/" target="_blank" rel="noopener">马克飞象</a></li><li><a href="http://www.jianshu.com/" target="_blank" rel="noopener">简书</a></li></ul></blockquote><h3 id="离线应用程序"><a href="#离线应用程序" class="headerlink" title="离线应用程序"></a>离线应用程序</h3><p>　　我选用的是<a href="https://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a>，<a href="http://www.sum16.com/resource/markdownpad-2-pro-key.html" target="_blank" rel="noopener">MarkdownPad 2 Pro 注册码</a>。初始使用发现代码块显示有问题，设置见：<a href="http://lutaf.com/208.htm" target="_blank" rel="noopener">终于搞定了 markdown编辑器的语法高亮</a></p><p>　　参考：<a href="http://www.jianshu.com/p/dcffb6f60fe2" target="_blank" rel="noopener">Markdown编辑器之比较</a>、<a href="http://www.open-open.com/news/view/1be6464" target="_blank" rel="noopener">实用的 Markdown 编辑器和工具</a>、<a href="http://www.zhihu.com/question/19637157" target="_blank" rel="noopener">用 Markdown 写作用什么文本编辑器？</a></p><h2 id="个人的一些配置（写给没搞过前端的人）"><a href="#个人的一些配置（写给没搞过前端的人）" class="headerlink" title="个人的一些配置（写给没搞过前端的人）"></a>个人的一些配置（写给没搞过前端的人）</h2><h3 id="安装Jacman主题："><a href="#安装Jacman主题：" class="headerlink" title="安装Jacman主题："></a>安装Jacman主题：</h3><p>请参考：<a href="https://github.com/wuchong/jacman" target="_blank" rel="noopener">https://github.com/wuchong/jacman</a></p><p> <strong>以下说明基于Jacman主题(详情参考该主题的配置说明：<a href="https://github.com/wuchong/jacman/wiki/How-To-Use-Jacman-(%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">点击</a>)</strong></p><h3 id="添加“关于”（用于介绍自己和博客）"><a href="#添加“关于”（用于介绍自己和博客）" class="headerlink" title="添加“关于”（用于介绍自己和博客）"></a>添加“关于”（用于介绍自己和博客）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure><p>在hexo\source\下会生成about目录，里面有个index.md，直接编辑就可以了。</p><h3 id="启用标签和分类"><a href="#启用标签和分类" class="headerlink" title="启用标签和分类"></a>启用标签和分类</h3><p>menu 默认没有启用 /tags 和 /categories 页面，如果需要启用请在博客目录下的source文件夹中分别建立tags 和 categories文件夹每个文件夹中分别包含一个index.md文件。内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout: tags (或categories)</span><br><span class="line">title: tags (或categories)</span><br></pre></td></tr></table></figure></p><p>因为主题中已经内置了这两个页面的模板，所以他们会被正确的解析出来。<br>在博文布局scaffolds\post.md（hexo new 默认使用该布局）里添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure></p><p>生成博文之后，就可以在博文里添加分类和标签了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories: 经验教程</span><br><span class="line">tags: [博客搭建, Hexo, Github, Gitcafe]</span><br></pre></td></tr></table></figure></p><h3 id="添加微博挂件"><a href="#添加微博挂件" class="headerlink" title="添加微博挂件"></a>添加微博挂件</h3><p>到<a href="http://app.weibo.com/tool/weiboshow" target="_blank" rel="noopener">这里</a>生成微博秀改名，然后替换jacman\layout_widget\weibo.ejs中的相应代码。</p><h3 id="博客主页下面的作者图片、介绍、微博、Email"><a href="#博客主页下面的作者图片、介绍、微博、Email" class="headerlink" title="博客主页下面的作者图片、介绍、微博、Email"></a>博客主页下面的作者图片、介绍、微博、Email</h3><p>图片直接替换themes\jacman\source\img中的author.jpg。<br>介绍在主题配置文件themes\jacman_config.yml中修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#### Author information</span><br><span class="line">author:</span><br><span class="line">  intro_line1:  &quot;Hello, I&apos;m Juke Zhang.&quot;  ## eg: &quot;Hello ,I&apos;m Larry Page in Google.&quot;</span><br><span class="line">  intro_line2:  &quot;This is my blog.&quot;  ## eg: &quot;This is my blog,believe it or not.&quot;</span><br><span class="line">  weibo: keke2014 ## e.g. wuchong1014 or 2176287895 for http://weibo.com/2176287895，注意，只需要填微博名，而不是完整的网址</span><br><span class="line">  ---</span><br><span class="line">  email: zhangjuke@qq.com ## e.g. wuchong1014@gmail.com</span><br></pre></td></tr></table></figure></p><h3 id="主题上面淡蓝色留白高度调节"><a href="#主题上面淡蓝色留白高度调节" class="headerlink" title="主题上面淡蓝色留白高度调节"></a>主题上面淡蓝色留白高度调节</h3><p>themes\jacman\source\css_partial\header.styl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header nav</span><br><span class="line">  ---</span><br><span class="line">    margin-top 0.1em</span><br></pre></td></tr></table></figure></p><h3 id="添加多说评论"><a href="#添加多说评论" class="headerlink" title="添加多说评论"></a>添加多说评论</h3><p>注册<a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a>，将设置的后台管理网址的用户名添加到主题配置文件themes\jacman_config.yml中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#### Comment</span><br><span class="line">duoshuo: </span><br><span class="line">  enable: true  ## duoshuo.com</span><br><span class="line">  short_name: jukezhang   ##e.g. wuchong   for duoshuo short name.</span><br></pre></td></tr></table></figure></p><p>如果想自定义多说评论显示，请参考：<a href="http://blog.csdn.net/jelope/article/details/19678633" target="_blank" rel="noopener">为Hexo添加多说评论功能(正文评论和列表评论数)</a></p><h3 id="右侧友情链接"><a href="#右侧友情链接" class="headerlink" title="右侧友情链接"></a>右侧友情链接</h3><p>在 themes\jacman\layout_widget\links.ejs 中添加。</p><h3 id="添加RSS和Sitemap"><a href="#添加RSS和Sitemap" class="headerlink" title="添加RSS和Sitemap"></a>添加RSS和Sitemap</h3><p>Jacman主题已经配置好，只需要安装在hexo的配置文件中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - hexo-generator-feed</span><br><span class="line">  - hexo-generator-sitemap</span><br></pre></td></tr></table></figure></p><p>并利用node.js在本地安装这两个插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://zipperary.com/2013/06/02/hexo-guide-5/" target="_blank" rel="noopener">hexo系列教程：（五）hexo博客的优化技巧续</a></p><h3 id="Markdown图片居中"><a href="#Markdown图片居中" class="headerlink" title="Markdown图片居中"></a>Markdown图片居中</h3><p>在图片文本之前添加一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center&quot; markdown=&quot;1&quot;&gt;</span><br><span class="line">![image description](image url)</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://trefoil.github.io/2013/10/23/cssmarkdown.html" target="_blank" rel="noopener">使用css让markdown生成的网页里图片居中</a></p><h3 id="Markdown在文本之前输入空格（段落缩进）"><a href="#Markdown在文本之前输入空格（段落缩进）" class="headerlink" title="Markdown在文本之前输入空格（段落缩进）"></a>Markdown在文本之前输入空格（段落缩进）</h3><p>将输入法切换到全角模式(shift+space)输入即可，或者使用代码：</p><blockquote><p>半方大的空白<code>&amp;ensp</code>;或<code>&amp;#8194</code>;<br>全方大的空白<code>&amp;emsp</code>;或<code>&amp;#8195</code>;<br>不断行的空白格<code>&amp;nbsp</code>;或<code>&amp;#160</code>;</p></blockquote><p>参考：<a href="http://www.zhihu.com/question/21420126" target="_blank" rel="noopener">在 Markdown 语言中，如何实现段首空格的显示 ？</a></p><h3 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h3><blockquote><ul><li>初始化新的Hexo项目: <code>hexo init</code></li><li>创建一篇新文章: <code>hexo new article_name</code></li><li>构建静态文件: <code>hexo generate</code>，简写为<code>hexo g</code></li><li>开启本地server进行预览:<code>hexo server</code>， 简写为<code>hexo s</code>。 执行后可以访问<code>localhost:4000</code>进行效果预览。</li><li>部署到远程服务器: <code>hexo depoly</code>，简写为<code>hexo d</code></li><li>也可把 <code>hexo g</code> 和 <code>hexo d</code> 合起来： <code>hexo d -g</code></li></ul></blockquote><h2 id="Markdown参考"><a href="#Markdown参考" class="headerlink" title="Markdown参考"></a>Markdown参考</h2><p><a href="https://gitcafe.com/GitCafe/Help/wiki/Markdown-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%E8%A1%A8#wiki" target="_blank" rel="noopener">Markdown 语法速查表</a><br><a href="https://help.github.com/articles/markdown-basics/" target="_blank" rel="noopener">Markdown Basics</a><br><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">Mastering Markdown</a><br><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a><br><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图</a><br><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图</a><br><a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">图标</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> Gitcafe </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
